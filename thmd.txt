// Version: 0.1.16.94
using System;
using System.Collections.Generic;
using Thmd.Configuration;
using Thmd.Logs;

namespace Thmd;

/// <summary>
/// Logger class for centralized logging functionality.
/// </summary>
public static class Logger
{
	private static List<string> _categories = new List<string> { "Console", "File" };

	private static AsyncLogger _log { get; set; } = new AsyncLogger();

	/// <summary>
	/// Gets the configuration settings for the logger.
	/// </summary>
	public static Config Config { get; set; } = Config.Instance;

	/// <summary>
	/// Gets the logger instance.
	/// </summary>
	public static AsyncLogger Log
	{
		get
		{
			return _log;
		}
		set
		{
			_log = value;
		}
	}

	/// <summary>
	/// Initializes the logging system.
	/// </summary>
	/// <returns>Async logger</returns>
	public static AsyncLogger InitLogs()
	{
		AsyncLogger asyncLogger = new AsyncLogger();
		asyncLogger.MinLogLevel = Config.LogLevel;
		asyncLogger.CategoryFilters["Console"] = true;
		asyncLogger.CategoryFilters["File"] = true;
		_log = asyncLogger;
		_log.AddSink(new CategoryFilterSink(new FileSink("Logs", "log", new TextFormatter(), 10485760, 5), new string[1] { "File" }));
		_log.AddSink(new CategoryFilterSink(new ConsoleSink(new TextFormatter()), new string[1] { "Console" }));
		return _log;
	}

	/// <summary>
	/// Initializes the logging system.
	/// </summary>
	/// <param name="level">log level</param>
	/// <param name="message">log message</param>
	/// <param name="category">log categories</param>
	/// <param name="exception">exception details</param>
	public static void AddLog(LogLevel level, string message, string[] category = null, Exception exception = null)
	{
		if (category != null)
		{
			foreach (string cat in _categories)
			{
				string[] array = category ?? Array.Empty<string>();
				foreach (string c in array)
				{
					if (!string.IsNullOrEmpty(c) && !cat.Equals(c, StringComparison.OrdinalIgnoreCase) && !_categories.Contains(c))
					{
						_categories.Add(c);
					}
				}
			}
		}
		_log.Log(level, _categories.ToArray(), message, exception);
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Compress\Rar\Rarer.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

using SharpCompress;
using SharpCompress.Archives;

using Thmd.Consolas;

namespace Thmd.Compress.Rar
{
    public class Rarer
    {
        Action<double> _progress;
        CancellationToken _cancellationToken;
        public void UnRar(string source_path, string target_directory)
        {
            try
            {
                if (SharpCompress.Archives.Rar.RarArchive.IsRarFile(source_path))
                {
                    var rar = SharpCompress.Archives.Rar.RarArchive.Open(source_path);
                    rar.ExtractToDirectory(target_directory, _progress, _cancellationToken);
                }
                else
                {
                    this.WriteLine("File is not a compressed rar file.");
                    
                    return;
                }
            }
            catch (Exception ex)
            {
                this.WriteLine(ex);
            }
            
        }
    }
}
// Version: 0.1.7.68



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Compress\Zip\Zipper.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Thmd.Compress.Zip
{
    public class Zipper
    {
    }
}
// Version: 0.1.7.68



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\Config.cs

// Config.cs
// Version: 0.1.16.84
// A singleton class for managing application configuration settings, including database connections,
// logging, VLC library settings, subtitles, updates, and plugins. Supports loading and saving
// configuration data to a JSON file with thread-safe access.

using System;
using System.IO;
using System.Windows.Media;

using Newtonsoft.Json;

using Thmd.Consolas;
using Thmd.Logs;

namespace Thmd.Configuration;

/// <summary>
/// A singleton class for managing application configuration settings.
/// Provides properties for database connections, logging, VLC library settings,
/// subtitles, updates, and plugins. Supports loading and saving configuration
/// data to a JSON file with thread-safe access using a singleton pattern.
/// </summary>
public class Config
{
    // Lock object for thread-safe singleton access.
    private static readonly object _lock = new object();

    // Singleton instance of the Config class.
    private static Config _instance;

    // Static instance of IPlaylistConfig for easy access.
    private static IPlaylistConfig _playlistConfig;
    private static UpdateConfig _updateConfig;
    private static OpenAiConfig _openAiConfig;
    private static PerformanceMonitorConfig _performanceMonitor;

    /// <summary>
    /// Gets or sets the database connection string.
    /// </summary>
    public string DatabaseConnectionString { get; set; }

    public string Language { get; set; }

    /// <summary>
    /// Gets or sets the maximum number of database connections allowed.
    /// </summary>
    public int MaxConnections { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether logging is enabled.
    /// </summary>
    public bool EnableLogging { get; set; }

    /// <summary>
    /// Gets or sets the directory path for storing log files.
    /// </summary>
    public string LogsDirectoryPath { get; set; }

    /// <summary>
    /// Gets or sets the path to the VLC library.
    /// </summary>
    public string LibVlcPath { get; set; } = "libvlc";

    /// <summary>
    /// Gets or sets a value indicating whether the VLC library is enabled.
    /// </summary>
    public bool EnableLibVlc { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether console logging is enabled.
    /// </summary>
    public bool EnableConsoleLogging { get; set; }

    /// <summary>
    /// Gets or sets the logging level (e.g., Info, Debug, Error).
    /// </summary>
    public LogLevel LogLevel { get; set; }

    /// <summary>
    /// Gets or sets the configuration settings for subtitles.
    /// </summary>
    public SubtitleConfig SubtitleConfig { get; set; }

    public static Config Instance
    {
        get
        {
            lock (_lock)
            {
                return _instance ?? (_instance = LoadFromJsonFile<Config>("config/config.json"));
            }
        }
    }

    private IPlaylistConfig _playerConfig;

    public IPlaylistConfig PlaylistConfig
    {
        get
        {
            lock (_lock)
            {
                return _playlistConfig ?? (_playlistConfig = LoadFromJsonFile<PlaylistConfig>("config/update.json"));
            }
        }
        set
        {
            _playlistConfig = value;
        }
    }

    public UpdateConfig UpdateConfig
    {
        get
        {
            lock (_lock)
            {
                return _updateConfig ?? (_updateConfig = LoadFromJsonFile<UpdateConfig>("config/update.json"));
            }
        }
        set
        {
            _updateConfig = value;
        }
    }

    /*public UpdateConfig PerhormanceMonitor
    {
        get
        {
            lock (_lock)
            {
                return _updateConfig ?? (_updateConfig = LoadFromJsonFile<UpdateConfig>("config/performance_monitor.json"));
            }
        }
        set
        {
            _updateConfig = value;
        }
    }*/

    public OpenAiConfig OpenAiConfig
    {
        get
        {
            lock (_lock)
            {
                return _openAiConfig ?? (_openAiConfig = LoadFromJsonFile<OpenAiConfig>("config/openai.json"));
            }
        }
        set
        {
            _openAiConfig = value;
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="Config"/> class with default values.
    /// </summary>
    public Config()
    {
        this.WriteLine("Inicjalizacja domyÅ›lnych ustawieÅ„ konfiguracji.");
        /*DatabaseConnectionString = "server=localhost;connection=default";
        Language = "pl_PL";
        MaxConnections = 10;
        EnableLogging = true;
        LogsDirectoryPath = "logs";
        ApiKey = "default-key";
        LibVlcPath = "libvlc";
        EnableLibVlc = true;
        LogLevel = LogLevel.Info;
        SubtitleConfig = new SubtitleConfig(24.0, "Arial", Brushes.WhiteSmoke, show_shadow: true, new Shadow());
        _updateConfig = new UpdateConfig
        {
            CheckForUpdates = true,
            UpdateUrl = "http://thmdplayer.softbery.org/update.rar",
            UpdatePath = "update",
            UpdateFileName = "update.rar",
            Version = "4.0.0",
            VersionUrl = "http://thmdplayer.softbery.org/version.txt",
            UpdateInterval = 86400,
            UpdateTimeout = 30
        };*/
        _updateConfig = LoadFromJsonFile<UpdateConfig>("config/config.json");
        _playlistConfig = LoadFromJsonFile<PlaylistConfig>("config/playlist.json");
        _openAiConfig = LoadFromJsonFile<OpenAiConfig>("config/openai.json");
    }

    /// <summary>
    /// Loads configuration settings from a specified JSON file.
    /// Creates a new configuration file with default values if the file does not exist.
    /// </summary>
    /// <typeparam name="T">The type of configuration to load.</typeparam>
    /// <param name="filePath">The path to the JSON configuration file.</param>
    /// <returns>An instance of type <typeparamref name="T"/> populated with the loaded settings.</returns>
    /// <exception cref="InvalidOperationException">Thrown if there is an error loading the configuration.</exception>
    public static T LoadFromJsonFile<T>(string filePath) where T : new()
    {
        try
        {
            Console.WriteLine($"Loading file {filePath}");
            if (!File.Exists(filePath))
            {
                T defaultConfig = new T();
                SaveToFile(filePath, defaultConfig);
                return defaultConfig;
            }
            string json = File.ReadAllText(filePath);
            return JsonConvert.DeserializeObject<T>(json);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"BÅ‚Ä…d Å‚adowania konfiguracji: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Saves the current configuration settings to a specified JSON file.
    /// Creates the directory if it does not exist.
    /// </summary>
    /// <param name="filePath">The path to save the JSON configuration file.</param>
    /// <exception cref="InvalidOperationException">Thrown if there is an error saving the configuration.</exception>
    public static void SaveToFile(string filePath, object obj)
    {
        try
        {
            FileInfo file_info = new FileInfo(filePath);
            string directory = file_info.Directory.FullName;
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }
            string json = JsonConvert.SerializeObject(obj, Formatting.Indented);
            File.WriteAllText(filePath, json);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("BÅ‚Ä…d zapisu konfiguracji: " + ex.Message, ex);
        }
    }

    /// <summary>
    /// Updates the configuration settings using the provided action and saves them to a file.
    /// Ensures thread-safe access during the update and save operation.
    /// </summary>
    /// <param name="updateAction">The action to update the configuration settings.</param>
    /// <param name="filePath">The path to save the JSON configuration file (default is "config.json").</param>
    public void UpdateAndSave(Action<Config> updateAction, string filePath = "config.json")
    {
        lock (_lock)
        {
            updateAction(this);
            SaveToFile(filePath, this);
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\IPlaylistConfig.cs

// IPlaylistConfig.cs
// Version: 0.1.16.93
// A class representing the configuration settings for playlists in the application.
// Stores properties such as default playlist path, shuffle mode, repeat mode, auto-play settings,
// and a list of media file paths or URIs.

using System.Collections.Generic;
using System.Windows;

using LibVLCSharp.Shared;

using Thmd.Media;
using Thmd.Repeats;

namespace Thmd.Configuration;

public class PlaylistConfig : IPlaylistConfig
{
    public string Name { get; set; }
    public bool EnableShuffle { get; set; } = true;
    public string Repeat { get; set; } = "None";
    public bool AutoPlay { get; set; } = true;
    public List<string> MediaList { get; set; } = new List<string>();
    public Point Position { get; set; }
    public Size Size { get; set; }
    public List<string> Subtitles { get; set; } = new List<string>();
    public bool SubtitleVisible {get;set;}=true;
    public int Current { get; set; }
}

/// <summary>
/// Represents the configuration settings for playlists in the application.
/// Provides properties to define the default playlist path, shuffle mode, repeat mode,
/// auto-play behavior, and a list of media file paths or URIs.
/// </summary>
public interface IPlaylistConfig
{
    public Point Position { get; set; }
    public Size Size { get; set; }
    /// <summary>
    /// Playlist name.
    /// </summary>
    public string Name { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether shuffle mode is enabled for playlist playback.
    /// Defaults to false.
    /// </summary>
    public bool EnableShuffle { get; set; }

    /// <summary>
    /// Gets or sets the repeat mode for playlist playback (e.g., None, One, All, Random).
    /// Defaults to <see cref="RepeatType.None"/>.
    /// </summary>
    public string Repeat { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether auto-play is enabled, starting playback automatically when a playlist is loaded.
    /// Defaults to true.
    /// </summary>
    public bool AutoPlay { get; set; }

    /// <summary>
    /// Gets or sets the list of media file paths or URIs in the playlist.
    /// Defaults to an empty list.
    /// </summary>
    public List<string> MediaList { get; set; }
    public List<string> Subtitles { get; set; }
    public bool SubtitleVisible { get; set; }
    public int Current { get; set; }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\OpenAiConfig.cs

namespace Thmd.Configuration
{
    public class OpenAiConfig
    {
        public string OpenApiKey { get; set; }
    }
}
// Version: 0.1.1.69



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\PerformanceMonitorConfig.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Thmd.Configuration
{
    public class PerformanceMonitorConfig
    {
        public bool EnablePerformanceMonitoring { get; set; }
        public int MonitoringInterval { get; set; } // in seconds
        public string LogFilePath { get; set; }
        public PerformanceMonitorConfig()
        {
            EnablePerformanceMonitoring = false;
            MonitoringInterval = 60; // Default to 60 seconds
            LogFilePath = "performance.log"; // Default log file path
        }
    }
}
// Version: 0.1.5.11



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\PluginConfig.cs

// PluginConfig.cs
// Version: 0.1.16.93
// A class representing the configuration settings for a plugin in the application.
// Stores properties such as the plugin's name, file path, enabled status, version, and description.

namespace Thmd.Configuration;

/// <summary>
/// Represents the configuration settings for a plugin in the application.
/// Provides properties to store the plugin's name, file path, enabled status, version, and description.
/// </summary>
public class PluginConfig
{
    /// <summary>
    /// Gets or sets the name of the plugin.
    /// </summary>
    public string PluginName { get; set; }

    /// <summary>
    /// Gets or sets the file path to the plugin.
    /// </summary>
    public string PluginPath { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether the plugin is enabled.
    /// </summary>
    public bool IsEnabled { get; set; }

    /// <summary>
    /// Gets or sets the version of the plugin.
    /// </summary>
    public string Version { get; set; }

    /// <summary>
    /// Gets or sets a description of the plugin.
    /// </summary>
    public string Description { get; set; }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\Shadow.cs

// Shadow.cs
// Version: 0.1.16.92
// A class representing the configuration settings for a shadow effect in the application.
// Stores properties such as color, depth, opacity, blur radius, and visibility for a shadow effect.

using System.Windows.Media;

namespace Thmd.Configuration;

/// <summary>
/// Represents the configuration settings for a shadow effect in the application.
/// Provides properties to define the color, depth, opacity, blur radius, and visibility of a shadow.
/// </summary>
public class Shadow
{
    /// <summary>
    /// Gets or sets the color of the shadow.
    /// Defaults to <see cref="Colors.Black"/>.
    /// </summary>
    public Color Color { get; set; } = Colors.Black;

    /// <summary>
    /// Gets or sets the depth of the shadow, determining its offset from the element.
    /// Defaults to 0.0.
    /// </summary>
    public double ShadowDepth { get; set; } = 0.0;

    /// <summary>
    /// Gets or sets the opacity of the shadow, ranging from 0.0 (fully transparent) to 1.0 (fully opaque).
    /// Defaults to 0.5.
    /// </summary>
    public double Opacity { get; set; } = 0.5;

    /// <summary>
    /// Gets or sets the blur radius of the shadow, controlling the softness of the shadow edges.
    /// Defaults to 10.0.
    /// </summary>
    public double BlurRadius { get; set; } = 10.0;

    /// <summary>
    /// Gets or sets a value indicating whether the shadow is visible.
    /// Defaults to true.
    /// </summary>
    public bool Visible { get; set; } = true;
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\SubtitleConfig.cs

// SubtitleConfig.cs
// Version: 0.1.16.93
// A class representing the configuration settings for subtitles in the application.
// Stores properties such as font size, font family, font color, and shadow settings for subtitle display.

using System.Windows.Media;

namespace Thmd.Configuration;

/// <summary>
/// Represents the configuration settings for subtitles in the application.
/// Provides properties to define the font size, font family, font color, and shadow settings for subtitle display.
/// </summary>
public class SubtitleConfig
{
    /// <summary>
    /// Gets or sets the font size for subtitles.
    /// </summary>
    public double FontSize { get; set; }

    /// <summary>
    /// Gets or sets the font family for subtitles.
    /// </summary>
    public FontFamily FontFamily { get; set; }

    /// <summary>
    /// Gets or sets the font color for subtitles.
    /// </summary>
    public Brush FontColor { get; set; }

    /// <summary>
    /// Gets or sets the shadow settings for subtitles.
    /// </summary>
    public Shadow Shadow { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="SubtitleConfig"/> class with specified subtitle settings.
    /// </summary>
    /// <param name="size">The font size for subtitles.</param>
    /// <param name="fontfamily">The name of the font family for subtitles.</param>
    /// <param name="color">The font color for subtitles.</param>
    /// <param name="show_shadow">A value indicating whether the shadow is visible.</param>
    /// <param name="shadow">The shadow settings for subtitles. If null, a default shadow is created.</param>
    public SubtitleConfig(double size, string fontfamily, Brush color, bool show_shadow, Shadow shadow = null)
    {
        FontSize = size;
        FontFamily = new FontFamily(fontfamily);
        FontColor = color;
        Shadow = shadow ?? new Shadow
        {
            Color = Colors.Black,
            ShadowDepth = 0.0,
            Opacity = 0.5,
            BlurRadius = 10.0,
            Visible = show_shadow
        };
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Configuration\UpdateConfig.cs

// UpdateConfig.cs
// Version: 0.1.16.92
// A class representing the configuration settings for application updates.
// Stores properties such as update check settings, URLs, file paths, version information, and timing settings.

namespace Thmd.Configuration;

/// <summary>
/// Represents the configuration settings for application updates.
/// Provides properties to define whether updates are checked, the URLs for updates and version information,
/// file paths, version details, and timing settings for update checks.
/// </summary>
public class UpdateConfig
{
    /// <summary>
    /// Gets or sets a value indicating whether the application should check for updates.
    /// Defaults to true.
    /// </summary>
    public bool CheckForUpdates { get; set; }

    /// <summary>
    /// Gets or sets the URL for downloading the update package.
    /// Defaults to "http://thmdplayer.softbery.org/update.rar".
    /// </summary>
    public string UpdateUrl { get; set; } = "http://thmdplayer.softbery.org/update.rar";

    /// <summary>
    /// Gets or sets the local directory path where update files are stored.
    /// Defaults to "update".
    /// </summary>
    public string UpdatePath { get; set; } = "update";

    /// <summary>
    /// Gets or sets the name of the update file.
    /// Defaults to "update".
    /// </summary>
    public string UpdateFileName { get; set; } = "update.rar";

    /// <summary>
    /// Gets or sets the current version of the application.
    /// Defaults to "1.0.0".
    /// </summary>
    public string Version { get; set; } = "1.0.0";

    /// <summary>
    /// Gets or sets the URL for retrieving the latest version information.
    /// Defaults to "http://thmdplayer.softbery.org/version.txt".
    /// </summary>
    public string VersionUrl { get; set; } = "http://thmdplayer.softbery.org/version.txt";

    /// <summary>
    /// Gets or sets the interval (in seconds) between update checks.
    /// Defaults to 86400 seconds (24 hours).
    /// </summary>
    public int UpdateInterval { get; set; } = 86400;

    /// <summary>
    /// Gets or sets the timeout (in seconds) for update operations.
    /// Defaults to 30 seconds.
    /// </summary>
    public int UpdateTimeout { get; set; } = 30;
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Consolas\ConsoleWriteLine.cs

// Version: 0.1.7.68
using System;
using System.Reflection;

namespace Thmd.Consolas
{
    /// <summary>
    /// Delegate for getting class name
    /// </summary>
    /// <returns>BaseString of Class</returns>
    public delegate string GetClassNameDelegate(object sender);

    /// <summary>
    /// Static class for extending Console.WriteLine functionality
    /// </summary>
    public static class ConsoleWriteLine
    {
        /// <summary>
        /// Get method base name by type name
        /// </summary>
        /// <returns>class name</returns>
        private static string GetName(object sender)
        {
            if (sender == null)
                return "Unknown";
            return sender.GetType().FullName; // Poprawka: uï¿½yj GetType().BaseString zamiast DeclaringType
        }

        /// <summary>
        /// Write line using Console.WriteLine() with exception
        /// </summary>
        /// <example>
        /// Console.WriteLine($"[{datetime}][{class_name}][{ex.HResult}]: {ex.Message}");
        /// </example>
        /// <param name="sender"></param>
        /// <param name="ex">Exception to use</param>
        public static void WriteLine(this object sender, Exception ex)
        {
            string data = DateTime.Now.ToString("dd-MM-yyyy H:mm:ss"); // Aktualizacja daty
            GetClassNameDelegate delegat = GetName; // Uï¿½ycie delegata
            var class_name = delegat(sender);

            if (ex != null)
                Console.WriteLine($"[{data}][{class_name}][{ex.HResult}]: {ex.Message}");
            else
                Console.WriteLine($"[{data}][{class_name}]: [{class_name}]");
        }

        /// <summary>
        /// Write line using Console.WriteLine() with string value
        /// </summary>
        /// <example>
        /// Console.WriteLine($"[{datetime}][{class_name}]: {msg}");
        /// </example>
        /// <param name="sender"></param>
        /// <param name="msg">string value</param>
        public static void WriteLine(this object sender, string msg)
        {
            string data = DateTime.Now.ToString("dd-MM-yyyy H:mm:ss"); // Aktualizacja daty
            GetClassNameDelegate delegat = GetName; // Uï¿½ycie delegata
            var class_name = delegat(sender);

            if (!string.IsNullOrEmpty(msg))
                Console.WriteLine($"[{data}][{class_name}]: {msg}");
            else
                Console.WriteLine($"[{data}][{class_name}]: [{class_name}]");
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\AddStreamView.xaml.cs

// Version: 0.1.0.10
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using Thmd.Translator;

namespace Thmd.Controls
{
    /// <summary>
    /// Logika interakcji dla klasy AddStreamView.xaml
    /// </summary>
    public partial class AddStreamView : UserControl
    {
        public string ReturnUrl;

        public AddStreamView()
        {
            InitializeComponent();
        }

        private void CancelButton(object sender, RoutedEventArgs e)
        {
            ReturnUrl = String.Empty;
        }

        private void AddButton_Click(object sender, RoutedEventArgs e)
        {
            XmlLanguage language = XmlLanguage.GetLanguage("pl");
            var l = Translator.Language.LoadLanguage("langs");
            if (l != null)
            {
                foreach (var item in l)
                {
                    if (item.Code == "pl_pl")
                    {
                        foreach (var item_translation in item.Translations)
                        {
                            if (item_translation.Control.GetType() == typeof(ControlBar))
                            {
                                
                            }
                        }
                    }
                }
            }
            
            

            ReturnUrl = _textBox.Text;
            this.Visibility = Visibility.Hidden;
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\ControlBar.xaml.cs

// Version: 0.1.10.15
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media.Animation;

using Thmd.Utilities;
using Thmd.Media;
using LibVLCSharp.Shared;
using System.Collections.Generic;
using Thmd.Translator;

namespace Thmd.Controls;

/// <summary>
/// Logika interakcji dla klasy ControlBox.xaml
/// </summary>
public partial class ControlBar : UserControl
{
    private IPlayer _player;
    private ObservableCollection<ILanguage> _languages;

    public Button BtnPlay => _playPauseButton;
    public Button BtnStop => _stopButton;
    public Button BtnNext => _fastForwardButton;
    public Button BtnPrevious => _rewindButton;
    public Button BtnMute => _muteButton;
    public Button BtnSubtitle => _openSubtitlesButton;
    public Button BtnOpen => _openMediaButton;
    public Button BtnPlaylist => _openPlaylistButton;
    public Slider SliderVolume => _volumeSlider;
    public Button BtnStream => _streamButton;

    public event PropertyChangedEventHandler PropertyChanged;

    // Existing properties

    // Property for media title
    public string MediaTitle
    {
        get => (string)GetValue(MediaTitleProperty);
        set => SetValue(MediaTitleProperty, value);
    }
    public static readonly DependencyProperty MediaTitleProperty =
        DependencyProperty.Register(nameof(MediaTitle), typeof(string), typeof(ControlBar), new PropertyMetadata("No Media", OnMediaTitleChanged));

    // New properties for timer and duration
    public string CurrentTime
    {
        get => (string)GetValue(CurrentTimeProperty);
        set => SetValue(CurrentTimeProperty, value);
    }
    public static readonly DependencyProperty CurrentTimeProperty =
        DependencyProperty.Register(nameof(Position), typeof(string), typeof(ControlBar), new PropertyMetadata("00:00", OnCurrentTimeChanged));

    public string MediaDuration
    {
        get => (string)GetValue(MediaDurationProperty);
        set => SetValue(MediaDurationProperty, value);
    }
    public static readonly DependencyProperty MediaDurationProperty =
        DependencyProperty.Register(nameof(MediaDuration), typeof(string), typeof(ControlBar), new PropertyMetadata("00:00", OnMediaDurationChanged));

    // Existing properties
    public double Volume
    {
        get => (double)GetValue(VolumeProperty);
        set => SetValue(VolumeProperty, value);
    }
    public static readonly DependencyProperty VolumeProperty =
        DependencyProperty.Register(nameof(Volume), typeof(double), typeof(ControlBar), new PropertyMetadata(50.0, OnVolumeChanged));

    public bool VolumePopupVisibility
    {
        get => (bool)GetValue(VolumePopupVisibilityProperty);
        set => SetValue(VolumePopupVisibilityProperty, value);
    }
    public static readonly DependencyProperty VolumePopupVisibilityProperty =
        DependencyProperty.Register(nameof(VolumePopupVisibility), typeof(bool), typeof(ControlBar), new PropertyMetadata(false));

    public string VolumePopupText
    {
        get => (string)GetValue(VolumePopupTextProperty);
        set => SetValue(VolumePopupTextProperty, value);
    }
    public static readonly DependencyProperty VolumePopupTextProperty =
        DependencyProperty.Register(nameof(VolumePopupText), typeof(string), typeof(ControlBar), new PropertyMetadata("Volume: 50"));

    public ObservableCollection<string> PlaylistItems
    {
        get => (ObservableCollection<string>)GetValue(PlaylistItemsProperty);
        set => SetValue(PlaylistItemsProperty, value);
    }
    public static readonly DependencyProperty PlaylistItemsProperty =
        DependencyProperty.Register(nameof(PlaylistItems), typeof(ObservableCollection<string>), typeof(ControlBar), new PropertyMetadata(new ObservableCollection<string>()));

    public int SelectedPlaylistIndex
    {
        get => (int)GetValue(SelectedPlaylistIndexProperty);
        set => SetValue(SelectedPlaylistIndexProperty, value);
    }
    public static readonly DependencyProperty SelectedPlaylistIndexProperty =
        DependencyProperty.Register(nameof(SelectedPlaylistIndex), typeof(int), typeof(ControlBar), new PropertyMetadata(-1));

    public bool PlaylistPopupVisibility
    {
        get => (bool)GetValue(PlaylistPopupVisibilityProperty);
        set => SetValue(PlaylistPopupVisibilityProperty, value);
    }
    public static readonly DependencyProperty PlaylistPopupVisibilityProperty =
        DependencyProperty.Register(nameof(PlaylistPopupVisibility), typeof(bool), typeof(ControlBar), new PropertyMetadata(false));

    public double BassLevel
    {
        get => (double)GetValue(BassLevelProperty);
        set => SetValue(BassLevelProperty, value);
    }
    public static readonly DependencyProperty BassLevelProperty =
        DependencyProperty.Register(nameof(BassLevel), typeof(double), typeof(ControlBar), new PropertyMetadata(0.0));

    public double MidLevel
    {
        get => (double)GetValue(MidLevelProperty);
        set => SetValue(MidLevelProperty, value);
    }
    public static readonly DependencyProperty MidLevelProperty =
        DependencyProperty.Register(nameof(MidLevel), typeof(double), typeof(ControlBar), new PropertyMetadata(0.0));

    public double TrebleLevel
    {
        get => (double)GetValue(TrebleLevelProperty);
        set => SetValue(TrebleLevelProperty, value);
    }
    public static readonly DependencyProperty TrebleLevelProperty =
        DependencyProperty.Register(nameof(TrebleLevel), typeof(double), typeof(ControlBar), new PropertyMetadata(0.0));

    public bool EqualizerPopupVisibility
    {
        get => (bool)GetValue(EqualizerPopupVisibilityProperty);
        set => SetValue(EqualizerPopupVisibilityProperty, value);
    }
    public static readonly DependencyProperty EqualizerPopupVisibilityProperty =
        DependencyProperty.Register(nameof(EqualizerPopupVisibility), typeof(bool), typeof(ControlBar), new PropertyMetadata(false));

    public ObservableCollection<string> RepeatModes
    {
        get => (ObservableCollection<string>)GetValue(RepeatModesProperty);
        set => SetValue(RepeatModesProperty, value);
    }
    public static readonly DependencyProperty RepeatModesProperty =
        DependencyProperty.Register(nameof(RepeatModes), typeof(ObservableCollection<string>), typeof(ControlBar), new PropertyMetadata(new ObservableCollection<string> { "None", "All", "One", "Random" }));

    public string RepeatMode
    {
        get => (string)GetValue(RepeatModeProperty);
        set => SetValue(RepeatModeProperty, value);
    }
    public static readonly DependencyProperty RepeatModeProperty =
        DependencyProperty.Register(nameof(RepeatMode), typeof(string), typeof(ControlBar), new PropertyMetadata("None", OnRepeatModeChanged));

    public bool RepeatPopupVisibility
    {
        get => (bool)GetValue(RepeatPopupVisibilityProperty);
        set => SetValue(RepeatPopupVisibilityProperty, value);
    }
    public static readonly DependencyProperty RepeatPopupVisibilityProperty =
        DependencyProperty.Register(nameof(RepeatPopupVisibility), typeof(bool), typeof(ControlBar), new PropertyMetadata(false));

    public bool IsMuted
    {
        get => (bool)GetValue(IsMutedProperty);
        set => SetValue(IsMutedProperty, value);
    }
    public static readonly DependencyProperty IsMutedProperty =
        DependencyProperty.Register(nameof(IsMuted), typeof(bool), typeof(ControlBar), new PropertyMetadata(false, OnIsMutedChanged));

    public VLCState PlayerState
    {
        get => (VLCState)GetValue(IsPlayingProperty);
        set => SetValue(IsPlayingProperty, value);
    }
    public static readonly DependencyProperty IsPlayingProperty =
        DependencyProperty.Register(nameof(PlayerState), typeof(bool), typeof(ControlBar), new PropertyMetadata(false, OnPlayerStateChanged));

    public string Position
    {
        get => _position;
        set
        {
            _position = value;
            _currentTimeTextBlock.Text = value;
            OnPropertyChanged(nameof(Position));
        }
    }

    public string Duration
    {
        get => _duration;
        set
        {
            _duration = value;
            _durationTextBlock.Text = value;
            OnPropertyChanged(nameof(Duration));
        }
    }

    // Store the volume before muting
    private double _previousVolume;
    private string _position = "00:00:00";
    private string _duration = "00:00:00";
    private int _scrollTextIndex = 0;

    public ControlBar()
    {
        InitializeComponent();

        _repeatButton.Click += (s, e) => RepeatPopupVisibility = !RepeatPopupVisibility;
        _repeatComboBox.SelectionChanged += (s, e) =>
        {
            RepeatPopupVisibility = false;
            UpdateRepeatButtonContent();
        };
        _muteButton.Click += (s, e) => ToggleMute();
        _volumeSlider.ValueChanged += (s, e) =>
        {
            if (IsMuted && Volume > 0)
            {
                IsMuted = false;
            }
            UpdateVolumePopupText();
        };

        UpdateRepeatButtonContent();
        UpdateMuteButtonContent();
    }

    public ControlBar(IPlayer player) : this()
    {
        _player = player;

        SubscribePlayerEvents();
    }

    public void SetPlayer(IPlayer player)
    {
        _player = player;

        SubscribePlayerEvents();
    }

    private void SubscribePlayerEvents()
    {
        // Subscribe player events
        if (_player != null)
        {

            _player.Playing += (s, e) => UpdateMediaTitle();
            _player.Stopped += (s, e) =>
            {
                MediaTitle = "No Media";
                CurrentTime = "00:00";
                MediaDuration = "00:00";
            };
            _player.TimeChanged += (s, e) => UpdateCurrentTime(e.Time);
            _player.LengthChanged += (s, e) => UpdateMediaDuration((long)_player.Playlist.Current.Duration.TotalMilliseconds);
        }
    }

    private static void OnPlayerStateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (ControlBar)d;
        if (control._player != null)
        {
            switch (control._player.State)
            {
                case VLCState.NothingSpecial:
                    break;
                case VLCState.Opening:
                    break;
                case VLCState.Buffering:
                    break;
                case VLCState.Playing:
                    control.UpdatePlayButtonContent();
                    break;
                case VLCState.Paused:
                    control.UpdatePlayButtonContent();
                    break;
                case VLCState.Stopped:
                    break;
                case VLCState.Ended:
                    break;
                case VLCState.Error:
                    break;
                default:
                    break;
            }
        }

        control.OnPropertyChanged(nameof(PlayerState));
    }

    private static void OnVolumeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (ControlBar)d;
        if (control._player != null)
        {
            control._player.Volume = control.IsMuted ? 0 : (int)control.Volume;
        }
        control.UpdateVolumePopupText();
        control.OnPropertyChanged(nameof(Volume));
    }

    private static void OnRepeatModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (ControlBar)d;
        control.UpdateRepeatButtonContent();
        control.OnPropertyChanged(nameof(RepeatMode));
    }

    private static void OnIsMutedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (ControlBar)d;
        if (control._player != null)
        {
            control._player.isMute = control.IsMuted;
            control._player.Volume = control.IsMuted ? 0 : (int)control.Volume;
        }
        control.UpdateMuteButtonContent();
        control.UpdateVolumePopupText();
        control.OnPropertyChanged(nameof(IsMuted));
    }

    private static void OnMediaTitleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (ControlBar)d;
        control.OnPropertyChanged(nameof(MediaTitle));
    }

    private static void OnCurrentTimeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (ControlBar)d;
        control.OnPropertyChanged(nameof(Position));
    }

    private static void OnMediaDurationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (ControlBar)d;
        control.OnPropertyChanged(nameof(MediaDuration));
    }

    private void UpdateRepeatButtonContent()
    {
        switch (RepeatMode)
        {
            case "All":
                _repeatButton.Content = "ðŸ”";
                _repeatButton.ToolTip = "Repeat All";
                break;
            case "One":
                _repeatButton.Content = "ðŸ”‚";
                _repeatButton.ToolTip = "Repeat One";
                break;
            case "Random":
                _repeatButton.Content = "ðŸ”€";
                _repeatButton.ToolTip = "Random";
                break;
            default:
                _repeatButton.Content = "ðŸ”";
                _repeatButton.ToolTip = "No Repeat";
                break;
        }
    }

    private void UpdateMuteButtonContent()
    {
        _muteButton.Content = IsMuted ? "ðŸ”‡" : "ðŸ”Š";
        _muteButton.ToolTip = IsMuted ? "Unmute" : "Mute";
    }

    private void UpdatePlayButtonContent()
    {
        _playPauseButton.Content = _player.State == LibVLCSharp.Shared.VLCState.Playing ? "â–¶" : "â¸ï¸";
        _playPauseButton.ToolTip = _player.State == LibVLCSharp.Shared.VLCState.Playing ? "Play" : "Pause";
    }

    private void ToggleMute()
    {
        if (IsMuted)
        {
            Volume = _previousVolume;
            IsMuted = false;
        }
        else
        {
            _previousVolume = Volume;
            Volume = 0;
            IsMuted = true;
        }
    }

    private void UpdateVolumePopupText()
    {
        VolumePopupText = IsMuted ? "Muted" : $"Volume: {Volume:F0}";
    }

    private void UpdateMediaTitle()
    {
        if (_player.Playlist.Current != null)
        {
            var title = _player.Playlist.Current.Name;
            MediaTitle = string.IsNullOrEmpty(title) ? "Unknown Title" : title;
        }
        else
        {
            MediaTitle = "No Media";
        }
    }

    private void UpdateCurrentTime(long milliseconds)
    {
        CurrentTime = FormatTime(milliseconds);
    }

    private void UpdateMediaDuration(long milliseconds)
    {
        MediaDuration = FormatTime(milliseconds);
    }

    private string FormatTime(long milliseconds)
    {
        TimeSpan time = TimeSpan.FromMilliseconds(milliseconds);
        if (time.TotalHours >= 1)
            return $"{(int)time.TotalHours:D2}:{time.Minutes:D2}:{time.Seconds:D2}";
        return $"{time.Minutes:D2}:{time.Seconds:D2}";
    }

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\IControlBar.cs

// Version: 0.1.10.27
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Controls;

namespace Thmd.Controls
{
    public interface IControlBar
    {
        public string BtnPlay { get; }       
        public string BtnStop { get; }      
        public string BtnNext { get; }    
        public string BtnPrevious { get; }        
        public string BtnMute { get; }        
        public string BtnSubtitle { get; }       
        public string BtnOpen { get; }        
        public string BtnPlaylist { get; }    
        public string SliderVolume { get; }        
        public string BtnStream { get; }   
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\InfoBox.xaml.cs

// Version: 0.1.12.73
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using Thmd.Media;

namespace Thmd.Controls;
/// <summary>
/// Logika interakcji dla klasy InfoBox.xaml
/// </summary>
public partial class InfoBox : UserControl
{
    private FrameworkElement _parent;

    public Action<string> DrawInfoText;

    public InfoBox()
    {
        InitializeComponent();
        DrawInfoText += InfoBox_DrawText;
    }

    public InfoBox(FrameworkElement parent) : this()
    {
        _parent = parent;
        _parent.SizeChanged += Parent_SizeChanged;
    }

    private async void InfoBox_DrawText(string obj)
    {
        var storyboard = this.FindResource("fadeInBox") as Storyboard; //.ShowByStoryboard(this, this.FindResource("fadeInBox") as Storyboard);

        await Utilities.StoryboardHelper.RunStoryboad(this, storyboard);

        await this.Dispatcher.InvokeAsync(() =>
        {
            _infoTextBlock.Text = obj;
        });

        await Task.Delay(7000);

        storyboard = this.FindResource("fadeOutBox") as Storyboard; //.ShowByStoryboard(this, this.FindResource("fadeInBox") as Storyboard);
        await Utilities.StoryboardHelper.RunStoryboad(this, storyboard);
    }

    private void Parent_SizeChanged(object sender, SizeChangedEventArgs e)
    {
        if (_parent != null)
        {
            double newFontSize = e.NewSize.Height / 25.0;
            _infoTextBlock.FontSize = ((newFontSize > 10.0) ? newFontSize : 10.0);
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\IProgressBar.cs

// Version: 0.1.10.27
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Thmd.Controls;
public interface IProgressBar
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\LogoImage.xaml.cs

// Version: 0.1.0.75
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using Thmd.Controls.Effects;

namespace Thmd.Controls
{
    /// <summary>
    /// Logika interakcji dla klasy LogoImage.xaml
    /// </summary>
    public partial class LogoImage : UserControl, INotifyPropertyChanged
    {
        private ImageSource _imageSource;
        private IEffect _effect;

        public ImageSource ImageSource
        {
            get => _imageSource;
            set
            {
                _imageSource = value;
                OnPropertyChanged(nameof(ImageSource));
            }
        }

        public IEffect Effect
        {
            get=>_effect;
            set
            {
                _effect = value;
                OnPropertyChanged(nameof(Effect));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        public LogoImage()
        {
            InitializeComponent();
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\PlaylistView.xaml.cs

// Version: 0.1.13.53
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Threading;

using Thmd.Consolas;
using Thmd.Media;
using Thmd.Utilities;

namespace Thmd.Controls;

/// <summary>
/// A custom ListView control for managing a playlist of video media items.
/// Provides functionality to play, pause, remove, and reorder videos, with support for
/// user interactions like double-click, right-click context menu actions, and drag-and-drop reordering
/// with a drop shadow effect for the dragged item.
/// Implements INotifyPropertyChanged for data binding and uses an ObservableCollection
/// to dynamically update the UI when the playlist changes.
/// Supports background thread operations for non-UI tasks using Task and Dispatcher for UI updates.
/// </summary>
public partial class PlaylistView : ListView, INotifyPropertyChanged
{
    // Stores the index of the currently selected video in the playlist.
    private int _currentIndex = 0;

    // Reference to the media player used to control video playback.
    private IPlayer _player;

    // Context menu for right-click interactions with playlist items.
    private ContextMenu _rightClickMenu;

    // Collection of videos in the playlist, bound to the ListView's ItemsSource.
    private ObservableCollection<VideoItem> _videos = new ObservableCollection<VideoItem>();

    // Stores the item being dragged during a drag-and-drop operation.
    private VideoItem _draggedItem;

    // Tracks whether a drag operation is in progress.
    private bool _isDragging;

    // 
    private int _draggedIndex = -1;

    //
    private int _lastTargetIndex = -1;

    // Stores the original background of the item being hovered over during drag.
    private Brush _originalBackground;

    // Minimum distance to start drag (to avoid accidental drags)
    private const double DragThreshold = 10.0;

    // Point where the mouse was pressed down
    private Point _startPoint;

    /// <summary>
    /// Add command
    /// </summary>
    public ICommand AddCommand { get; private set; }

    /// <summary>
    /// Remove command
    /// </summary>
    public ICommand RemoveCommand { get; private set; }

    /// <summary>
    /// Edit command
    /// </summary>
    public ICommand EditCommand { get; private set; }

    /// <summary>
    /// Close command
    /// </summary>
    public ICommand CloseCommand { get; private set; }

    public ICommand SavePlaylistCommand { get; private set; }
    public ICommand LoadPlaylistCommand { get; private set; }

    /// <summary>
    /// Gets or sets the collection of videos in the playlist and updates the UI.
    /// </summary>
    public ObservableCollection<VideoItem> Videos
    {
        get => _videos;
        set
        {
            Dispatcher.InvokeAsync(() =>
            {
                _videos = value;
                base.ItemsSource = _videos;;
                SetValue(VideosProperty, value);
                OnPropertyChanged(nameof(Videos));
            });
        }
    }

    public static readonly DependencyProperty VideosProperty =
        DependencyProperty.Register("Videos", typeof(ObservableCollection<VideoItem>), typeof(PlaylistView),
            new PropertyMetadata(new ObservableCollection<VideoItem>(), OnVideosChanged));

    private static void OnVideosChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var playlistView = (PlaylistView)d;
        playlistView.Dispatcher.Invoke(() =>
        {
            playlistView.ItemsSource = playlistView.Videos;
        });
    }

    /// <summary>
    /// Gets or sets the index of the current video, ensuring valid bounds.
    /// Returns -1 if the playlist is empty.
    /// </summary>
    public int CurrentIndex
    {
        get
        {
            if (Videos == null || Videos.Count == 0)
            {
                return -1;
            }
            int itemCount = Videos.Count;
            if (_currentIndex >= itemCount)
            {
                _currentIndex = 0;
            }
            if (_currentIndex < 0)
            {
                _currentIndex = itemCount - 1;
            }
            return _currentIndex;
        }
        set
        {
            _currentIndex = value;
            Dispatcher.Invoke(() => OnPropertyChanged("CurrentIndex"));
        }
    }

    /// <summary>
    /// Gets the index of the next video in the playlist, looping to 0 if at the end.
    /// Returns -1 if the playlist is empty.
    /// </summary>
    public int NextIndex
    {
        get
        {
            if (Videos == null || Videos.Count == 0)
            {
                return -1;
            }
            return (_currentIndex != Videos.Count - 1) ? (_currentIndex + 1) : 0;
        }
    }

    /// <summary>
    /// Gets the index of the previous video in the playlist, looping to the end if at the start.
    /// Returns -1 if the playlist is empty.
    /// </summary>
    public int PreviousIndex
    {
        get
        {
            if (Videos == null || Videos.Count == 0)
            {
                return -1;
            }
            return (_currentIndex == 0) ? (Videos.Count - 1) : (_currentIndex - 1);
        }
    }

    /// <summary>
    /// Gets the next video in the playlist based on <see cref="NextIndex"/>.
    /// </summary>
    public VideoItem Next => Videos != null && NextIndex >= 0 ? Videos[NextIndex] : null;

    /// <summary>
    /// Gets the previous video in the playlist based on <see cref="PreviousIndex"/>.
    /// </summary>
    public VideoItem Previous => Videos != null && PreviousIndex >= 0 ? Videos[PreviousIndex] : null;

    /// <summary>
    /// Moves to the next video in the playlist and returns it.
    /// Updates <see cref="CurrentIndex"/> and notifies the UI of the change.
    /// </summary>
    public VideoItem MoveNext
    {
        get
        {
            if (Videos == null || Videos.Count == 0) return null;
            _currentIndex = NextIndex;
            Dispatcher.Invoke(() => OnPropertyChanged("CurrentIndex"));
            return Videos[CurrentIndex];
        }
    }

    /// <summary>
    /// Moves to the previous video in the playlist and returns it.
    /// Updates <see cref="CurrentIndex"/> and notifies the UI of the change.
    /// </summary>
    public VideoItem MovePrevious
    {
        get
        {
            if (Videos == null || Videos.Count == 0) return null;
            _currentIndex = PreviousIndex;
            Dispatcher.Invoke(() => OnPropertyChanged("CurrentIndex"));
            return Videos[CurrentIndex];
        }
    }

    /// <summary>
    /// Gets or sets the current video in the playlist.
    /// </summary>
    public VideoItem Current
    {
        get
        {
            return Videos != null && CurrentIndex >= 0 ? Videos[CurrentIndex] : null;
        }
        set
        {
            if (Videos != null && CurrentIndex >= 0)
            {
                Videos[CurrentIndex] = value;
                Dispatcher.Invoke(() => OnPropertyChanged("Current"));
            }
        }
    }

    public int Count
    {
        get => Videos != null ? Videos.Count : 0;
    }

    /// <summary>
    /// Occurs when a property value changes, used for data binding.
    /// </summary>
    public event PropertyChangedEventHandler PropertyChanged;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlaylistView"/> class.
    /// </summary>
    public PlaylistView()
    {
        InitializeComponent();

        base.DataContext = this;
        base.ItemsSource = Videos;

        // Enable drag-and-drop
        AllowDrop = true;

        // Initialize commands
        AddCommand = new RelayCommand(Add);
        RemoveCommand = new RelayCommand(Remove);
        EditCommand = new RelayCommand(Edit);
        CloseCommand = new RelayCommand(Close);
        SavePlaylistCommand = new RelayCommand(SavePlaylist);
        LoadPlaylistCommand = new RelayCommand(LoadPlaylist);

        // Initialize the context menu
        _rightClickMenu = new ContextMenu();
        MenuItem playItem = new MenuItem { Header = "Play" };
        MenuItem removeItem = new MenuItem { Header = "Remove" };
        MenuItem moveToTopItem = new MenuItem { Header = "Move to Top" };
        MenuItem moveUpper = new MenuItem { Header = "Move Upper" };
        MenuItem moveLower = new MenuItem { Header = "Move Lower" };
        _rightClickMenu.Items.Add(playItem);
        _rightClickMenu.Items.Add(removeItem);
        _rightClickMenu.Items.Add(moveUpper);
        _rightClickMenu.Items.Add(moveLower);
        _rightClickMenu.Items.Add(moveToTopItem);

        // Event handlers for menu items
        playItem.Click += MenuItemPlay_Click;
        removeItem.Click += MenuItemRemove_Click;
        moveToTopItem.Click += MenuItemMoveToTop_Click;
        moveUpper.Click += MenuItemMoveUpper_Click;
        moveLower.Click += MenuItemMoveLower_Click;

        // Set the context menu for the ListView
        this.ContextMenu = _rightClickMenu;

        // Subscribe to mouse events
        this.MouseDoubleClick += ListView_MouseDoubleClick;
    }

    // Metoda dla przycisku "Dodaj"
    private void Add(object parameter)
    {
        // Logika dla dodawania elementu do playlisty
        //MessageBox.Show("Dodawanie nowego elementu do playlisty.");
        _player.GetCurrentFrame();
        
    }

    // Metoda dla przycisku "UsuÅ„"
    private void Remove(object parameter)
    {
        // Logika dla usuwania elementu z playlisty
        //NewAsync(BaseString, "");
    }

    // Metoda dla przycisku "Edytuj"
    private void Edit(object parameter)
    {
        // Logika dla edycji elementu playlisty
        MessageBox.Show("Edycja wybranego elementu playlisty.");
    }

    // Metoda dla przycisku "Zamknij"
    private void Close(object parameter)
    {
        // Logic for hide playlist
        this.Visibility = Visibility.Collapsed;
    }

    private void SavePlaylist(object parameter)
    {
        _player.SavePlaylistConfig();        
    }

    public void LoadPlaylist(object parameter)
    {
        _player.LoadPlaylistConfig();
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);
    }

    public PlaylistView(IPlayer player) : this()
    {
        _player = player;
    }

    public void SetPlayer(IPlayer player)
    {
        _player = player;
    }

    /// <summary>
    /// Raises the <see cref="PropertyChanged"/> event to notify the UI of property changes.
    /// </summary>
    /// <param name="propertyName">The name of the property that changed.</param>
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    /// <summary>
    /// Clears all videos from the playlist and unsubscribes from their events in a background task.
    /// </summary>
    public Task ClearTracksAsync()
    {
        return Task.Run(() =>
        {
            if (Videos == null) return;
            var videosToClear = Videos.ToList();
            foreach (VideoItem video in videosToClear)
            {
                video.PositionChanged -= Video_PositionChanged;
                video.MouseDown -= Media_MouseDown;
            }
            Dispatcher.Invoke(() =>
            {
                Videos.Clear();
                CurrentIndex = -1;
            });
        });
    }

    /// <summary>
    /// Checks if a video is already in the playlist based on its URI.
    /// </summary>
    /// <param name="media">The video to check for.</param>
    /// <returns>True if the video is in the playlist; otherwise, false.</returns>
    public bool Contains(VideoItem media)
    {
        if (media == null || Videos == null) return false;
        return Videos.Any(item => item.Uri == media.Uri);
    }

    /// <summary>
    /// Removes a video from the playlist and adjusts the current index if necessary in a background task.
    /// </summary>
    /// <param name="media">The video to remove.</param>
    /// <returns>A task that returns the removed video, or null if the video was not found.</returns>
    public Task<VideoItem> RemoveAsync(VideoItem media)
    {
        return Task.Run(() =>
        {
            if (media == null || Videos == null) return null;
            int index = Videos.ToList().FindIndex(video => video.Uri == media.Uri);
            if (index >= 0)
            {
                VideoItem item = Videos[index];
                item.PositionChanged -= Video_PositionChanged;
                item.MouseDown -= Media_MouseDown;
                Dispatcher.Invoke(() =>
                {
                    Videos.RemoveAt(index);
                    if (index < CurrentIndex)
                    {
                        CurrentIndex--;
                    }
                    else if (index == CurrentIndex && Videos.Count > 0)
                    {
                        CurrentIndex = Math.Min(CurrentIndex, Videos.Count - 1);
                    }
                    else if (Videos.Count == 0)
                    {
                        CurrentIndex = -1;
                    }
                });
                Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Removed video {item.Name} at index {index}");
                return item;
            }
            return null;
        });
    }

    /// <summary>
    /// Clears the current playlist to start a new one in a background task.
    /// </summary>
    /// <param name="name">The name of the new playlist (not currently used).</param>
    /// <param name="description">The description of the new playlist (not currently used).</param>
    public Task NewAsync(string name, string description)
    {
        return ClearTracksAsync();
    }

    /// <summary>
    /// Adds a single video to the playlist and sets up its player and event handlers in a background task.
    /// </summary>
    /// <param name="media">The video to add.</param>
    public Task AddAsync(VideoItem media)
    {
        return Task.Run(() =>
        {
            if (media == null || Contains(media)) return;
            media.SetPlayer(_player);
            media.PositionChanged += Video_PositionChanged;
            media.MouseDown += Media_MouseDown;
            Dispatcher.Invoke(() => Videos.Add(media));
            Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Added video {media.Name}");
        });
    }

    private void Media_MouseDown(object sender, MouseButtonEventArgs e)
    {
        this.WriteLine("CLICKED");
    }

    /// <summary>
    /// Adds multiple videos to the playlist and sets up their player and event handlers in a background task.
    /// </summary>
    /// <param name="medias">The array of videos to add.</param>
    public Task AddAsync(VideoItem[] medias)
    {
        return Task.Run(async () =>
        {
            if (medias == null) return;
            foreach (VideoItem media in medias)
            {
                await AddAsync(media);
            }
        });
    }

    /// <summary>
    /// Handles position changes in a video and logs the event.
    /// </summary>
    /// <param name="sender">The video that triggered the position change.</param>
    /// <param name="newPosition">The new position of the video playback.</param>
    private void Video_PositionChanged(object sender, double newPosition)
    {
        if (sender is VideoItem video)
        {
            Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Position changed for {video.Name} to {newPosition}");
        }
    }

    /// <summary>
    /// Handles double-click events to play the selected video.
    /// </summary>
    /// <param name="sender">The source of the event.</param>
    /// <param name="e">The mouse event arguments.</param>
    private void ListView_MouseDoubleClick(object sender, MouseButtonEventArgs e)
    {
        if (SelectedItem is VideoItem selectedVideo)
        {
            PlayVideo(selectedVideo);
            Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Double-clicked to play video {selectedVideo.Name}");
        }
    }

    /// <summary>
    /// Plays a video selected from the context menu.
    /// </summary>
    /// <param name="video">The video to play.</param>
    private void PlayVideo(VideoItem video)
    {
        this.Dispatcher.InvokeAsync(() =>
        {
            if (video != null && _player != null)
            {
                Current?.Stop();
                CurrentIndex = Videos.IndexOf(video);
                _player.Play(video);
                Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Context menu play video {video.Name}");
            }
        });
    }

    /// <summary>
    /// Removes a video selected from the context menu and shows a confirmation message.
    /// </summary>
    /// <param name="video">The video to remove.</param>
    private async void RemoveVideo(VideoItem video)
    {
        if (video != null)
        {
            bool confirm = await Dispatcher.InvokeAsync(() =>
                MessageBox.Show($"Remove {video.Name} from playlist?", "Confirm Remove", MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes
            );
            if (confirm)
            {
                await RemoveAsync(video);
                Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Context menu removed video {video.Name}");
            }
        }
    }

    /// <summary>
    /// Moves a video selected from the context menu to the top of the playlist.
    /// </summary>
    /// <param name="video">The video to move to the top.</param>
    private void MoveVideoToTop(VideoItem video)
    {
        if (video != null && Videos != null)
        {
            int currentIndex = Videos.IndexOf(video);
            if (currentIndex > 0)
            {
                Dispatcher.Invoke(() => Videos.Move(currentIndex, 0));
                Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Moved video {video.Name} to top");
            }
        }
    }

    protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e)
    {
        base.OnPreviewMouseLeftButtonDown(e);
        var listViewItem = FindAncestor<ListViewItem>((DependencyObject)e.OriginalSource);
        if (listViewItem != null)
        {
            _draggedItem = (VideoItem)listViewItem.DataContext;
            _draggedIndex = Videos.IndexOf(_draggedItem);
        }
    }

    protected override void OnMouseMove(MouseEventArgs e)
    {
        base.OnMouseMove(e);
        if (e.LeftButton == MouseButtonState.Pressed && _draggedItem != null)
        {
            var data = new DataObject(typeof(VideoItem), _draggedItem);
            DragDrop.DoDragDrop(this, data, DragDropEffects.Move);
        }
    }

    protected override void OnDragOver(DragEventArgs e)
    {
        base.OnDragOver(e);
        e.Effects = DragDropEffects.None;

        // Reset IsDragOver dla wszystkich elementÃ³w
        foreach (var item in Items)
        {
            if (ItemContainerGenerator.ContainerFromItem(item) is ListViewItem listViewItem)
            {
                DragDropHelper.SetIsDragOver(listViewItem, false);
            }
        }

        if (e.Data.GetDataPresent(typeof(VideoItem)))
        {
            var targetPoint = e.GetPosition(this);
            var (targetItem, insertAfter) = GetItemAtPoint(targetPoint);
            if (targetItem != null)
            {
                int targetIndex = Videos.IndexOf(targetItem);
                if (targetIndex >= 0 && targetIndex != _lastTargetIndex && targetIndex != _draggedIndex)
                {
                    Dispatcher.Invoke(() =>
                    {
                        Videos.Move(_draggedIndex, targetIndex);
                        _draggedIndex = targetIndex;
                        _lastTargetIndex = targetIndex;
                    });
                }
                // Ustaw IsDragOver na elemencie docelowym
                var listViewItem = FindAncestor<ListViewItem>((DependencyObject)VisualTreeHelper.HitTest(this, targetPoint)?.VisualHit);
                if (listViewItem != null)
                {
                    DragDropHelper.SetIsDragOver(listViewItem, true);
                }
                e.Effects = DragDropEffects.Move;
            }
        }
        e.Handled = true;
    }

    protected override void OnDragLeave(DragEventArgs e)
    {
        base.OnDragLeave(e);
        foreach (var item in Items)
        {
            if (ItemContainerGenerator.ContainerFromItem(item) is ListViewItem listViewItem)
            {
                DragDropHelper.SetIsDragOver(listViewItem, false);
            }
        }
        e.Handled = true;
    }

    protected override void OnDrop(DragEventArgs e)
    {
        base.OnDrop(e);
        foreach (var item in Items)
        {
            if (ItemContainerGenerator.ContainerFromItem(item) is ListViewItem listViewItem)
            {
                DragDropHelper.SetIsDragOver(listViewItem, false);
            }
        }
        if (e.Data.GetDataPresent(typeof(VideoItem)))
        {
            var droppedItem = (VideoItem)e.Data.GetData(typeof(VideoItem));
            var targetPoint = e.GetPosition(this);
            var (targetItem, insertAfter) = GetItemAtPoint(targetPoint);
            if (targetItem != null)
            {
                int targetIndex = Videos.IndexOf(targetItem);
                if (targetIndex >= 0 && targetIndex != _draggedIndex)
                {
                    if (_draggedIndex != -1)
                    {
                        Dispatcher.Invoke(() =>
                        {
                            Videos.Move(_draggedIndex, targetIndex);
                            this.WriteLine($"PlaylistView: Moved video {droppedItem.Name}:{_draggedIndex} to index {targetIndex}");
                        });
                    }
                }
            }
        }
        _draggedItem = null;
        _draggedIndex = -1;
        _lastTargetIndex = -1;
        e.Handled = true;
    }

    private (VideoItem, bool) GetItemAtPoint(Point point)
    {
        var hitTestResult = VisualTreeHelper.HitTest(this, point);
        if (hitTestResult != null)
        {
            var listViewItem = FindAncestor<ListViewItem>((DependencyObject)hitTestResult.VisualHit);
            if (listViewItem != null)
            {
                var item = (VideoItem)listViewItem.DataContext;
                if (item != null && Videos.Contains(item))
                {
                    // Oblicz pozycjÄ™ kursora wzglÄ™dem ListViewItem
                    var relativePoint = point;
                    var scrollViewer = FindAncestor<ScrollViewer>(this);
                    if (scrollViewer != null)
                    {
                        relativePoint = this.TranslatePoint(point, listViewItem);
                    }
                    var itemHeight = listViewItem.ActualHeight;
                    bool insertAfter = relativePoint.Y > itemHeight / 2;
                    return (item, insertAfter);
                }
            }
        }
        return (null, false);
    }

    private static T FindAncestor<T>(DependencyObject current) where T : DependencyObject
    {
        while (current != null && !(current is T))
        {
            current = VisualTreeHelper.GetParent(current);
        }
        return current as T;
    }

    /// <summary>
    /// Gets the insert index based on drop position.
    /// </summary>
    private int GetInsertIndex(Point position)
    {
        if (Videos == null || Videos.Count == 0) return 0;
        HitTestResult hitTest = VisualTreeHelper.HitTest(this, position);
        ListViewItem item = FindAncestor<ListViewItem>((DependencyObject)hitTest.VisualHit);
        if (item != null)
        {
            return ItemContainerGenerator.IndexFromContainer(item);
        }
        return Videos.Count;
    }

    private bool IsSupportedMediaFile(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return false;
        string[] supportedExtensions = { ".mp4", ".mkv", ".avi", ".mov", ".flv", ".wmv", ".m4v", ".webm" };
        string extension = System.IO.Path.GetExtension(filePath)?.ToLowerInvariant();
        return supportedExtensions.Contains(extension);
    }

    /// <summary>
    /// Handles the MouseLeave event to reset the dragging state and remove the adorner.
    /// </summary>
    private void OnMouseLeave(object sender, MouseEventArgs e)
    {
        if (e.LeftButton == MouseButtonState.Pressed && _isDragging)
        {
            _isDragging = false;
        }
        _draggedItem = null;
        _draggedIndex = -1;
        _lastTargetIndex = -1;
    }

    private void MenuItemPlay_Click(object sender, RoutedEventArgs e)
    {
        if (SelectedItem != null)
            PlayVideo(SelectedItem as VideoItem);
    }

    private void MenuItemMoveToTop_Click(object sender, RoutedEventArgs e)
    {
        if (SelectedItem != null)
            MoveVideoToTop(SelectedItem as VideoItem);
    }

    private void MenuItemRemove_Click(object sender, RoutedEventArgs e)
    {
        if (SelectedItem != null)
            RemoveVideo(SelectedItem as VideoItem);
    }

    private void MenuItemMoveUpper_Click(object sender, RoutedEventArgs e)
    {
        if (SelectedItem != null)
        {
            VideoItem video = SelectedItem as VideoItem;
            int currentIndex = Videos.IndexOf(video);
            if (currentIndex > 0)
            {
                Dispatcher.Invoke(() => Videos.Move(currentIndex, currentIndex - 1));
                Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Moved video {video.Name} upper");
            }
        }
    }

    private void MenuItemMoveLower_Click(object sender, RoutedEventArgs e)
    {
        if (SelectedItem != null)
        {
            VideoItem video = SelectedItem as VideoItem;
            int currentIndex = Videos.IndexOf(video);
            if (currentIndex < Videos.Count - 1)
            {
                Dispatcher.Invoke(() => Videos.Move(currentIndex, currentIndex + 1));
                Logger.Log.Log(Thmd.Logs.LogLevel.Info, new string[2] { "Console", "File" }, $"PlaylistView: Moved video {video.Name} lower");
            }
        }
    }

    // Helper RelayCommand class, implement ICommand
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Func<object, bool> _canExecute;

        public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\ProgressBarView.xaml.cs

// Version: 0.1.10.25
using System;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Input;
using System.Windows.Media.Animation;

using Newtonsoft.Json.Linq;

using Thmd.Media;

namespace Thmd.Controls;

public partial class ProgressBarView : UserControl, INotifyPropertyChanged
{
    //private string _progressText;
    //private string _popupText;
    private TimeSpan _duration;
    private double _bufforBarValue;
    private IPlayer _player;

    public ProgressBarView()
    {
        InitializeComponent();
        DataContext = this;
        /*_progressBar.MouseMove += ProgressBar_MouseMove;
        _progressBar.MouseDown += ProgressBar_MouseDown;*/
        _progressBar.ValueChanged += ProgressBar_ValueChanged;
        _popup.IsOpen = false;
        _popup.MouseLeave += Popup_MouseLeave;
    }

    private void Popup_MouseLeave(object sender, MouseEventArgs e)
    {
        _popup.IsOpen = false;
    }

    private void ProgressBar_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
    {
        _progressBar.Value = e.NewValue;
        _rectangleBufforBar.Margin = new Thickness(_progressBar.ActualWidth / Value, 0, 0, 0);
    }

    public ProgressBarView(IPlayer player) : this()
    {
        _player = player;
    }

    public void SetPlayer(IPlayer player)
    {
        _player = player;
    }

    public string ProgressText
    {
        get => _progressText.Text;
        set
        {
            if (_progressText.Text != value)
            {
                _progressText.Text = value;
                OnPropertyChanged(nameof(ProgressText));
            }
        }
    }

    public string PopupText
    {
        get => _popupText.Text;
        set
        {
            if (_popupText.Text != value)
            {
                _popupText.Text = value;
                OnPropertyChanged(nameof(PopupText));
            }
        }
    }

    public TimeSpan Duration
    {
        get => _duration;
        set
        {
            if (_duration != value)
            {
                _duration = value;
                _progressBar.Maximum = value.TotalMilliseconds;
                ProgressText = $"00:00:00/{value:hh\\:mm\\:ss}";
                OnPropertyChanged(nameof(Duration));
            }
        }
    }
    private double _value = 0.0;
    public double Value
    {
        get => _value;
        set
        {
            if (_value != value)
            {
                _value = value;
                _progressBar.Value = value;
                _rectangleBufforBar.Margin = new Thickness(_progressBar.ActualWidth / Value, 0, 0, 0);
                UpdateProgressText();
                SeekRequested?.Invoke(this, TimeSpan.FromMilliseconds(value));
                OnPropertyChanged(nameof(Value));
            }
        }
    }

    public void SetValue(double value)
    {
        _progressBar.Value = value;
    }

    public double BufforBarValue
    {
        get => _bufforBarValue;
        set
        {
            if (_bufforBarValue != value)
            {
                _bufforBarValue = value;
                _rectangleBufforBar.Width = (_progressBar.ActualWidth > 0) ? (value / _progressBar.Maximum) * _progressBar.ActualWidth : 0;
                _rectangleBufforBar.Width -= _value;
                OnPropertyChanged(nameof(BufforBarValue));
            }
        }
    }

    public double Maximum
    {
        get => _progressBar.Maximum;
        set
        {
            _progressBar.Maximum = value;
            OnPropertyChanged(nameof(Maximum));
        }
    }

    public double Minimum
    {
        get => _progressBar.Minimum;
        set
        {
            _progressBar.Minimum = value;
            OnPropertyChanged(nameof(Minimum));
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    public event EventHandler<TimeSpan> SeekRequested; // Zdarzenie dla przewijania

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    private void OnPropertyChanged<T>(string propertyName, ref T field, T value)
    {
        if (field != null || value == null)
        {
            if (field == null)
            {
                return;
            }
            object obj = value;
            if (field.Equals(obj))
            {
                return;
            }
        }
        field = value;
        this.PropertyChanged?.Invoke(field, new PropertyChangedEventArgs(propertyName));
    }

    private void UpdateProgressText()
    {
        TimeSpan currentTime = TimeSpan.FromMilliseconds(_progressBar.Value);
        ProgressText = $"{currentTime.Hours:00}:{currentTime.Minutes:00}:{currentTime.Seconds:00}/{_duration:hh\\:mm\\:ss}";
    }

    protected override void OnMouseEnter(MouseEventArgs e)
    {
        base.OnMouseEnter(e);
        _popup.IsOpen = false;
        _rectangleMouseOverPoint.Visibility = Visibility.Visible;
    }

    protected override void OnMouseLeave(MouseEventArgs e)
    {
        base.OnMouseLeave(e);
        _popup.IsOpen = false;
        _rectangleMouseOverPoint.Visibility = Visibility.Hidden;
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\SubtitleControl.xaml.cs

// SubtitleControl.xaml.cs
// Version: 0.1.5.51
// A custom user control for displaying subtitles from an SRT file with support for formatting tags
// such as <i>, <b>, <u>, <font color="...">, and <font size="...">.
// Enhanced with AI-powered subtitle translation and subtitle buffering for performance optimization.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Effects;

using Newtonsoft.Json; // Required for JSON serialization
using Newtonsoft.Json.Linq; // Required for JObject

using Thmd.Consolas;
using Thmd.Controls.Enums;
using Thmd.Logs;
using Thmd.Subtitles;

namespace Thmd.Controls;

/// <summary>
/// A custom user control for displaying subtitles from an SRT file with support for formatting tags
/// such as <i>, <b>, <u>, <font color="...">, and <font size="...">.
/// Now includes AI integration for translating subtitles using OpenAI API and subtitle buffering
/// to improve performance by caching processed subtitles.
/// </summary>
public partial class SubtitleControl : UserControl
{
    /// <summary>
    /// Delegate for handling time change events.
    /// </summary>
    /// <param name="sender">The object that raised the event.</param>
    /// <param name="time">The current time position in the subtitle timeline.</param>
    public delegate void TimeHandlerDelegate(object sender, TimeSpan time);

    private TimeSpan _positionTime = TimeSpan.Zero;
    private SubtitleManager _subtitleManager;
    private double _fontSize = 48.0;
    private Brush _backgroundBrush = new SolidColorBrush(Colors.Transparent);
    private Brush _subtitleBrush = new SolidColorBrush(Colors.White);
    private bool _shadowSubtitle = true;
    private FontFamily _fontFamily = new FontFamily("Segoe UI");
    private bool _sizeToFit = true;
    private Size _size;
    private FrameworkElement _parent;
    private string _filePath;
    private TextStyle _textStyle = TextStyle.Normal;

    // AI Integration Properties
    private string _openAiApiKey; // Set this via configuration or property
    private string _targetLanguage = "en"; // Default target language (e.g., English)
    private bool _enableAiTranslation = false; // Flag to enable/disable AI translation
    private readonly SemaphoreSlim _apiSemaphore = new SemaphoreSlim(1, 1);
    private DateTime _lastApiCall = DateTime.MinValue;
    private const int MinIntervalMs = 5000; // Minimum 1 second between calls

    // Buffering Properties
    private readonly ConcurrentDictionary<TimeSpan, string> _subtitleCache = new ConcurrentDictionary<TimeSpan, string>();
    private const int CacheTimeWindow = 10000; // 10 seconds window for cache validity (in milliseconds)

    /// <summary>
    /// Occurs when the position time changes, allowing synchronization with the media player.
    /// </summary>
    public event TimeHandlerDelegate TimeChanged;

    /// <summary>
    /// Gets or sets the OpenAI API key for AI translation.
    /// </summary>
    public string OpenAiApiKey
    {
        get => _openAiApiKey;
        set => _openAiApiKey = value;
    }

    /// <summary>
    /// Gets or sets the target language for AI translation (ISO code, e.g., "en", "fr").
    /// </summary>
    public string TargetLanguage
    {
        get => _targetLanguage;
        set => _targetLanguage = value;
    }

    /// <summary>
    /// Gets or sets whether AI translation is enabled for subtitles.
    /// </summary>
    public bool EnableAiTranslation
    {
        get => _enableAiTranslation;
        set
        {
            _enableAiTranslation = value;
            if (value && !string.IsNullOrEmpty(_filePath))
            {
                // Clear cache when enabling translation to force re-processing
                _subtitleCache.Clear();
                GetSubtitle(PositionTime);
            }
        }
    }

    /// <summary>
    /// Gets the TextBlock used to display the subtitle text.
    /// </summary>
    public FrameworkElement TextBlock => _subtitleTextBlock;

    /// <summary>
    /// Gets or sets a value indicating whether a shadow effect is applied to the subtitle text.
    /// </summary>
    public bool SubtitleShadow
    {
        get => _shadowSubtitle;
        set
        {
            if (_shadowSubtitle != value)
            {
                if (value)
                {
                    DropShadowEffect e = new DropShadowEffect();
                    _subtitleTextBlock.Effect = e;
                }
                else
                {
                    _subtitleTextBlock.Effect = null;
                }
                _shadowSubtitle = value;
            }
        }
    }

    /// <summary>
    /// Gets or sets the font family for the subtitle text.
    /// </summary>
    public FontFamily SubtitleFontFamily
    {
        get => _fontFamily;
        set
        {
            if (_fontFamily != value)
            {
                _fontFamily = value;
                _subtitleTextBlock.FontFamily = value;
                OnPropertyChanged("SubtitleFontFamily", ref _fontFamily, value);
            }
        }
    }

    /// <summary>
    /// Gets or sets the font size for the subtitle text.
    /// </summary>
    /// <remarks>
    /// This serves as the default font size unless overridden by <font size="..."> tags in the subtitle text.
    /// </remarks>
    public double SubtitleFontSize
    {
        get => _fontSize;
        set
        {
            if (_fontSize != value)
            {
                _subtitleTextBlock.FontSize = value;
                OnPropertyChanged("_fontSize", ref _fontSize, value);
            }
        }
    }

    /// <summary>
    /// Gets or sets the background brush for the subtitle control.
    /// </summary>
    public Brush SubtitleBackground
    {
        get => _backgroundBrush;
        set
        {
            if (_backgroundBrush != value)
            {
                base.Background = value;
                OnPropertyChanged("_backgroundBrush", ref _backgroundBrush, value);
            }
        }
    }

    /// <summary>
    /// Gets or sets the foreground brush for the subtitle text.
    /// </summary>
    /// <remarks>
    /// This serves as the default text color unless overridden by <font color="..."> tags in the subtitle text.
    /// </remarks>
    public Brush SubtitleBrush
    {
        get => _subtitleBrush;
        set
        {
            if (_subtitleBrush != value)
            {
                _subtitleTextBlock.Foreground = value;
                OnPropertyChanged("_subtitleBrush", ref _subtitleBrush, value);
            }
        }
    }

    /// <summary>
    /// Gets or sets the path to the SRT subtitle file.
    /// </summary>
    /// <remarks>
    /// Setting this property initializes the subtitle manager and triggers subtitle processing.
    /// If AI translation is enabled, subtitles will be translated using OpenAI.
    /// </remarks>
    public string FilePath
    {
        get => _filePath;
        set
        {
            if (_filePath != value)
            {
                _filePath = value;
                OnPropertyChanged("FilePath", ref _filePath, value);
                _subtitleCache.Clear(); // Clear cache when file changes
                _subtitleManager = new SubtitleManager(value);
                GetSubtitle(PositionTime);
            }
        }
    }

    /// <summary>
    /// Gets or sets the current subtitle text.
    /// </summary>
    public string Text { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the base text style for the subtitle text block.
    /// </summary>
    /// <remarks>
    /// This applies a uniform style to the entire text block. Inline formatting tags
    /// (<i>, <b>, etc.) override this style for specific text segments.
    /// </remarks>
    public TextStyle TextStyle
    {
        get => _textStyle;
        set
        {
            if (_textStyle != value)
            {
                if (value == TextStyle.Bold)
                    _subtitleTextBlock.FontWeight = FontWeights.Bold;
                else if (value == TextStyle.Italic)
                    _subtitleTextBlock.FontStyle = FontStyles.Italic;
                else if (value == TextStyle.BoldItalic)
                {
                    _subtitleTextBlock.FontWeight = FontWeights.Bold;
                    _subtitleTextBlock.FontStyle = FontStyles.Italic;
                }
                else
                {
                    _subtitleTextBlock.FontWeight = FontWeights.Normal;
                }
                OnPropertyChanged("TextStyle", ref _textStyle, value);
            }
        }
    }

    /// <summary>
    /// Gets or sets the current time position in the subtitle timeline.
    /// </summary>
    /// <remarks>
    /// Setting this property triggers the retrieval and display of the appropriate subtitle.
    /// If AI translation is enabled, the subtitle text will be translated before display.
    /// Triggers the TimeChanged event to notify listeners (e.g., Player).
    /// </remarks>
    public TimeSpan PositionTime
    {
        get => _positionTime;
        set
        {
            if (_positionTime != value)
            {
                _positionTime = value;
                GetSubtitle(value);
                TimeChanged?.Invoke(this, value); // Notify listeners of time change
            }
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SubtitleControl"/> class.
    /// </summary>
    public SubtitleControl()
    {
        InitializeComponent();
        // AI Setup: Load API key from config if available
        _openAiApiKey = Thmd.Configuration.Config.Instance.OpenAiConfig.OpenApiKey ?? string.Empty; // Assume Config has OpenAiApiKey property added
    }

    private async void GetSubtitle(TimeSpan time)
    {
        await Task.Run(async () =>
        {
            if (_subtitleManager != null)
            {
                string cachedText;
                if (_subtitleCache.TryGetValue(time, out cachedText))
                {
                    await base.Dispatcher.InvokeAsync(() =>
                    {
                        _subtitleTextBlock.Inlines.Clear();
                        ProcessSubtitleText(cachedText);
                    });
                    return;
                }

                string textToProcess = string.Empty;
                bool subtitleFound = false;

                foreach (Subtitle current in _subtitleManager.Subtitles)
                {
                    if (time >= current.StartTime && time < current.EndTime)
                    {
                        textToProcess = string.Join(Environment.NewLine, current.TextLines);
                        subtitleFound = true;
                        break;
                    }
                }

                if (subtitleFound)
                {
                    if (EnableAiTranslation)
                    {
                        textToProcess = await TranslateWithAiAsync(textToProcess);
                    }

                    await base.Dispatcher.InvokeAsync(() =>
                    {
                        _subtitleTextBlock.Inlines.Clear();
                        ProcessSubtitleText(textToProcess);
                    });

                    _subtitleCache.TryAdd(time, textToProcess);
                }
                else
                {
                    await base.Dispatcher.InvokeAsync(() =>
                    {
                        _subtitleTextBlock.Inlines.Clear();
                        _subtitleTextBlock.Inlines.Add(new Run(string.Empty));
                    });
                }

                var oldEntries = _subtitleCache.Where(kvp => (time.TotalMilliseconds - kvp.Key.TotalMilliseconds) > CacheTimeWindow).ToArray();
                foreach (var entry in oldEntries)
                {
                    string removed;
                    _subtitleCache.TryRemove(entry.Key, out removed);
                }
            }
        });
    }

    /// <summary>
    /// Translates the given text using OpenAI API with rate limiting.
    /// </summary>
    /// <param name="text">The text to translate.</param>
    /// <returns>The translated text or original if translation fails.</returns>
    private async Task<string> TranslateWithAiAsync(string text)
    {
        if (string.IsNullOrEmpty(_openAiApiKey))
        {
            this.WriteLine("OpenAI API key is not set. Skipping translation.");
            return text;
        }

        // Check rate limit
        var timeSinceLastCall = (DateTime.Now - _lastApiCall).TotalMilliseconds;
        if (timeSinceLastCall < MinIntervalMs)
        {
            await Task.Delay((int)(MinIntervalMs - timeSinceLastCall)); // Wait if too frequent
        }

        try
        {
            await _apiSemaphore.WaitAsync(); // Ensure single-threaded access to API
            _lastApiCall = DateTime.Now;

            using (var client = new HttpClient())
            {
                client.DefaultRequestHeaders.Add("Authorization", $"Bearer {_openAiApiKey}");

                var requestBody = new
                {
                    model = "gpt-4.1-mini-2025-04-14",
                    messages = new[]
                    {
                    new { role = "system", content = $"Translate the following text to {_targetLanguage}." },
                    new { role = "user", content = text }
                }
                };

                var content = new StringContent(JsonConvert.SerializeObject(requestBody), Encoding.UTF8, "application/json");
                var response = await client.PostAsync("https://api.openai.com/v1/chat/completions", content);

                this.WriteLine(response.Content.ToString());

                if (response.IsSuccessStatusCode)
                {
                    var responseString = await response.Content.ReadAsStringAsync();
                    var jsonResponse = JObject.Parse(responseString);
                    return jsonResponse["choices"][0]["message"]["content"].ToString();
                }
                else
                {
                    this.WriteLine($"AI Translation failed: {response.StatusCode} - {response.ReasonPhrase}");
                    return text;
                }
            }
        }
        catch (Exception ex)
        {
            this.WriteLine($"AI Translation exception: {ex.Message}");
            return text;
        }
        finally
        {
            _apiSemaphore.Release();
        }
    }

    /// <summary>
    /// Processes subtitle text to apply formatting based on tags such as <i>, <b>, <u>, 
    /// <font color="...">, and <font size="...">.
    /// </summary>
    /// <param name="text">The subtitle text containing formatting tags.</param>
    /// <remarks>
    /// This method parses the input text for formatting tags and applies the corresponding styles
    /// (italic, bold, underline, color, and font size) to the subtitle text block.
    /// Invalid color or size values fall back to the default <see cref="SubtitleBrush"/> or <see cref="SubtitleFontSize"/>.
    /// </remarks>
    private void ProcessSubtitleText(string text)
    {
        var parts = Regex.Split(text, "(<i>|</i>|<b>|</b>|<u>|</u>|<font\\s+color=\"[^\"]*\">|<font\\s+size=\"[^\"]*\">|</font>)");
        bool isItalic = false;
        bool isBold = false;
        bool isUnderline = false;
        Brush currentColor = _subtitleBrush;
        double? currentFontSize = null;

        foreach (var part in parts)
        {
            if (Regex.IsMatch(part, "<font\\s+color=\"[^\"]*\">"))
            {
                var match = Regex.Match(part, "<font\\s+color=\"([^\"]*)\">");
                if (match.Success)
                {
                    string colorName = match.Groups[1].Value;
                    try { currentColor = new SolidColorBrush((Color)ColorConverter.ConvertFromString(colorName)); }
                    catch { currentColor = _subtitleBrush; }
                }
                continue;
            }
            else if (Regex.IsMatch(part, "<font\\s+size=\"[^\"]*\">"))
            {
                var match = Regex.Match(part, "<font\\s+size=\"([^\"]*)\">");
                if (match.Success)
                {
                    string sizeValue = match.Groups[1].Value;
                    if (double.TryParse(sizeValue, out double fontSize))
                    {
                        currentFontSize = fontSize > 0 ? fontSize : _fontSize;
                    }
                    else
                    {
                        currentFontSize = _fontSize;
                    }
                }
                continue;
            }
            else if (part == "</font>")
            {
                currentColor = _subtitleBrush;
                currentFontSize = null;
                continue;
            }
            else if (part == "<i>") { isItalic = true; continue; }
            else if (part == "</i>") { isItalic = false; continue; }
            else if (part == "<b>") { isBold = true; continue; }
            else if (part == "</b>") { isBold = false; continue; }
            else if (part == "<u>") { isUnderline = true; continue; }
            else if (part == "</u>") { isUnderline = false; continue; }

            if (!string.IsNullOrEmpty(part))
            {
                var run = new Run(part)
                {
                    Foreground = currentColor,
                    FontSize = currentFontSize ?? _fontSize
                };
                Inline current = run;

                if (isBold) current = new Bold(current);
                if (isItalic) current = new Italic(current);
                if (isUnderline) current = new Underline(current);

                _subtitleTextBlock.Inlines.Add(current);
            }
        }
    }

    /// <summary>
    /// Handles size changes of the parent element to adjust the subtitle font size.
    /// </summary>
    /// <param name="sender">The parent element that raised the event.</param>
    /// <param name="e">The event data containing the new size information.</param>
    private void OnParentSizeChanged(object sender, SizeChangedEventArgs e)
    {
        if (_parent != null)
        {
            double newFontSize = e.NewSize.Height / 15.0;
            SubtitleFontSize = ((newFontSize > 10.0) ? newFontSize : 10.0);
        }
    }

    private void OnPropertyChanged<T>(string propertyName, ref T field, T value)
    {
        if (!EqualityComparer<T>.Default.Equals(field, value))
        {
            field = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\TimerBox.xaml.cs

// Version: 0.1.13.18
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using Thmd.Media;

namespace Thmd.Controls;
/// <summary>
/// Logika interakcji dla klasy TimerBox.xaml
/// </summary>
public partial class TimerBox : UserControl
{
    private IPlayer _player;
    private string _timer = "00:00:00";

    public event PropertyChangedEventHandler PropertyChanged;

    public string Timer
    {
        get => _timer;
        set
        {
            _timer = value;
            _timerTextBlock.Text = value;
            OnPropertyChanged(nameof(Timer));
        }
    }

    public TimerBox()
    {
        InitializeComponent();
    }

    public TimerBox(IPlayer player) : this()
    {
        _player = player;
    }

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\VlcPlayerView.xaml.cs

// Version: 0.1.8.85
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Imaging;

using LibVLCSharp.Shared;

using Microsoft.VisualBasic;
using Microsoft.Win32;
using Microsoft.Xaml.Behaviors;

using Thmd.Configuration;
using Thmd.Consolas;
using Thmd.Converters;
using Thmd.Devices.Keyboards;
using Thmd.Media;
using Thmd.Utilities;

using static System.Windows.Forms.VisualStyles.VisualStyleElement.TaskbarClock;

namespace Thmd.Controls;

/// <summary>
/// Logic interaction for class VlcPlayerView.xaml
/// Represents a WPF UserControl that integrates a VLC media player for video playback with controls, playlist, and subtitle support.
/// Implements IPlayer interface for media operations and INotifyPropertyChanged for data binding.
/// </summary>
public partial class VlcPlayerView : UserControl, IPlayer, INotifyPropertyChanged
{
    // System execution state flags to prevent system sleep during playback.
    private const uint ES_CONTINUOUS = 2147483648u;
    private const uint ES_SYSTEM_REQUIRED = 1u;
    private const uint ES_DISPLAY_REQUIRED = 2u;
    private const uint ES_AWAYMODE_REQUIRED = 64u;

    // When you don't move mouse or keybord this IntPtr:
    // Combination to block sleep mode.
    private const uint BLOCK_SLEEP_MODE = 2147483651u;
    // Combination to allow sleep mode.
    private const uint DONT_BLOCK_SLEEP_MODE = 2147483648u;

    /// <summary>
    /// Sets the system execution state to prevent sleep during playback.
    /// </summary>
    /// <param name="esFlags">The execution state flags.</param>
    /// <returns>The previous execution state.</returns>
    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern uint SetThreadExecutionState(uint esFlags);

    private VLCState _state;

    /// <summary>
    /// Gets or sets the current status of the media player.
    /// </summary>
    public PlaylistView Playlist
    {
        get => _playlist;
        private set
        {
            if (_playlist == null)
            {
                _playlist = new PlaylistView(this);
            }
            _playlist = value;
        }
    }
    /// <summary>
    /// Count items in Videos
    /// </summary>
    public int Count { get => _playlist.Videos.Count(); }
    /// <summary>
    /// Gets or sets the visibility of the playlist.
    /// </summary>
    public Visibility PlaylistVisibility { get => _playlist.Visibility; set => _playlist.Visibility = value; }
    /// <summary>
    /// Gets or sets the progress bar control for displaying playback progress.
    /// </summary>
    public ProgressBarView ProgressBar { get => _progressBar; set => _progressBar = value; }
    /// <summary>
    /// Gets or sets the control bar for playback controls (play, pause, stop, etc.).
    /// </summary>
    public ControlBar ControlBar { get => _controlBar; set => _controlBar = value; }
    /// <summary>
    /// Gets or sets the current playback position of the media.
    /// </summary>
    public TimeSpan Position
    {
        get => _position;
        set
        {
            _position = value;
            Seek(_position);
            OnPropertyChanged(nameof(Position), ref _position, value);
        }
    }
    /// <summary>
    /// Indicates whether media is currently playing.
    /// </summary>
    public bool isPlaying
    {
        get => _playing;
        set
        {
            _playing = value;
            if (value)
            {
                _paused = false;
                _stopped = false;
            }
            OnPropertyChanged(nameof(isPlaying), ref _playing, value);
        }
    }
    /// <summary>
    /// Indicates whether media playback is currently paused.
    /// </summary>
    public bool isPaused
    {
        get => _paused;
        set
        {
            _paused = value;
            if (value)
            {
                _playing = false;
                _stopped = false;
            }
            OnPropertyChanged(nameof(isPaused), ref _paused, value);
        }
    }
    /// <summary>
    /// Indicates whether media playback is currently stopped.
    /// </summary>
    public bool isStoped
    {
        get => _stopped;
        set
        {
            _stopped = value;
            if (value)
            {
                _paused = false;
                _playing = false;
            }
            OnPropertyChanged(nameof(isStoped), ref _stopped, value);
        }
    }
    /// <summary>
    /// Gets or sets the subtitle control for managing subtitles.
    /// </summary>
    public SubtitleControl SubtitleControl
    {
        get => _subtitleControl;
        set => _subtitleControl = value;
    }
    /// <summary>
    /// Gets or sets the visibility of subtitles.
    /// </summary>
    public Visibility SubtitleVisibility { get => _subtitleVisibility; set => _subtitleVisibility = value; }
    /// <summary>
    /// Gets or sets the volume level of the media player (0 to 100).
    /// </summary>
    public double Volume
    {
        get => _volume;
        set
        {
            if (value < 0.0) value = 0.0;
            else if (value > 100.0) value = 100.0;
            _volume = value;
            _controlBar.SliderVolume.Value = value;
            _mediaPlayer.Volume = (int)value; // Ensure this is applied
            OnPropertyChanged(nameof(Volume), ref _volume, value);
        }
    }
    /// <summary>
    /// Gets or sets whether the audio is muted.
    /// </summary>
    public bool isMute
    {
        get => _muted;
        set
        {
            if (value)
            {
                _muted = true;
                _mediaPlayer.Mute = true;
            }
            else
            {
                _muted = false;
                _mediaPlayer.Mute = false;
            }
            OnPropertyChanged("isMute", ref _muted, value);
        }
    }
    /// <summary>
    /// Gets or sets a value indicating whether the media is in fullscreen mode.
    /// </summary>
    public bool Fullscreen
    {
        get => _fullscreen;
        set
        {
            this.Fullscreen();
            _fullscreen = ScreenHelper.IsFullscreen;
            OnPropertyChanged("Fullscreen", ref _fullscreen, value);
        }
    }
    /// <summary>
    /// Gets the currently loaded media item.
    /// </summary>
    public VideoItem Media { get => _playlist.Current; }

    /// <summary>
    /// Mouse sleep, time with controls like ControlBar or ProgressBar are hide.
    /// </summary>
    public double MouseSleeps { get; private set; } = 7;
    /// <summary>
    /// Gets or sets the current VLC player state.
    /// </summary>
    public VLCState State
    {
        get => _mediaPlayer.State;
        set
        {
            OnPropertyChanged(nameof(State));
        }
    }

    /// <summary>
    /// Gets or sets whether upscale is enabled for low-resolution media.
    /// </summary>
    public bool isUpscale
    {
        get => _isUpscale;
        set
        {
            _isUpscale = value;
            OnPropertyChanged(nameof(isUpscale), ref _isUpscale, value);
        }
    }

    /// <summary>
    /// Occurs when a property value changes, used for data binding.
    /// </summary>
    public event PropertyChangedEventHandler PropertyChanged;
    public event EventHandler<EventArgs> Playing;
    public event EventHandler<EventArgs> Stopped;
    public event EventHandler<EventArgs> LengthChanged;
    public event EventHandler<MediaPlayerTimeChangedEventArgs> TimeChanged;

    private LibVLC _libVLC;
    private LibVLCSharp.Shared.MediaPlayer _mediaPlayer;
    private double _volume = 100.0;
    private bool _muted;
    private bool _playing;
    private bool _paused;
    private bool _stopped;
    private bool _fullscreen = false;
    private TimeSpan _position;
    private readonly Random _random = new Random();
    private VideoItem _media;
    private Visibility _subtitleVisibility = Visibility.Hidden;
    private Visibility _playlistVisibility = Visibility.Hidden;
    private Visibility _addStreamViewVisibility = Visibility.Hidden;
    private bool _isMouseMove;
    private BackgroundWorker _mouseNotMoveWorker;
    private bool _isUpscale = false;

    /// <summary>
    /// Initialize class
    /// Initializes the VLC player view, sets up controls, events, and loads configurations.
    /// </summary>
    public VlcPlayerView()
    {
        InitializeComponent();
        Core.Initialize();

        // Set player references for controls
        _controlBar.SetPlayer(this);
        _playlist.SetPlayer(this);
        _progressBar.SetPlayer(this);

        _controlBar.SliderVolume.MouseDown += ControlBar_SliderVolume_MouseDown;
        _controlBar.SliderVolume.MouseMove += ControlBar_SliderVolume_MouseMove;

        // Progress bar events
        _progressBar.MouseDown += ProgressBar_MouseDown;
        _progressBar.MouseMove += ProgressBar_MouseMove;

        // VlcControl events and values
        string[] mediaOptions = new string[] { "--no-video-title-show", "--no-sub-autodetect-file" };//,"--verbose=2","--aout=any" };
        _libVLC = new LibVLC(mediaOptions);
        _mediaPlayer = new LibVLCSharp.Shared.MediaPlayer(_libVLC);
        _mediaPlayer.EnableHardwareDecoding = false;
        _mediaPlayer.EnableKeyInput = false;
        _mediaPlayer.EnableMouseInput = false;
        _mediaPlayer.TimeChanged += OnTimeChanged;
        _mediaPlayer.EndReached += OnEndReached;
        _mediaPlayer.Playing += OnPlaying;
        _mediaPlayer.Stopped += OnStopped;
        _mediaPlayer.Paused += OnPaused;
        _mediaPlayer.Buffering += OnBuffering;
        _mediaPlayer.MediaChanged += OnMediaChanged;
        _mediaPlayer.VolumeChanged += OnVolumeChanged;

        _mediaPlayer.Volume = (int)_volume;

        _videoView.MediaPlayer = _mediaPlayer;
        _videoView.Background = Brushes.Black;

        // Resize helpers for control bar and playlist
        var resizer1 = new ResizeControlHelper(_controlBar);
        var resizer2 = new ResizeControlHelper(_playlist);
        //var resizer3 = new ResizeControlHelper(_addStreamView);

        // Buttons event handlers
        ControlBarButtonEvent();

        // Mouse not moving worker
        _mouseNotMoveWorker = new BackgroundWorker();
        _mouseNotMoveWorker.DoWork += MouseNotMoveWorker_DoWork;
        _mouseNotMoveWorker.RunWorkerAsync();

        LoadPlaylistConfig();
        LoadOpenAiConfig();
        SaveUpdateConfig();
        LoadUpdateConfig();
    }

    /// <summary>
    /// Loads the OpenAI configuration from JSON file.
    /// </summary>
    public void LoadOpenAiConfig()
    {
        var ai = Configuration.Config.LoadFromJsonFile<OpenAiConfig>("config/openai.json");
        Config.Instance.OpenAiConfig = ai;
    }

    /// <summary>
    /// Loads the update configuration from JSON file.
    /// </summary>
    public void LoadUpdateConfig()
    {
        var up = Configuration.Config.LoadFromJsonFile<UpdateConfig>("config/update.json");
        Config.Instance.UpdateConfig = up;
    }

    /// <summary>
    /// Saves the default update configuration to JSON file.
    /// </summary>
    public void SaveUpdateConfig()
    {
        var up = new UpdateConfig();
        up.CheckForUpdates = true;
        up.UpdateUrl = "http://thmdplayer.softbery.org/themedit.zip";
        up.UpdatePath = "update";
        up.UpdateFileName = "themedit.zip";
        up.Version = "4.0.0";
        up.VersionUrl = "http://thmdplayer.softbery.org/version.txt";
        up.UpdateInterval = 86400;
        up.UpdateTimeout = 30;

        Configuration.Config.SaveToFile("config/update.json", up);
    }

    /// <summary>
    /// Loads the playlist configuration from JSON file and applies it to the player.
    /// </summary>
    public void LoadPlaylistConfig()
    {
        try
        {
            var pl = Configuration.Config.LoadFromJsonFile<PlaylistConfig>("config/playlist.json");

            _controlBar.RepeatMode = pl.Repeat;

            for (int i = 0; i < pl.MediaList.Count; i++)
            {
                var media = new VideoItem(pl.MediaList[i]);
                media.SubtitlePath = pl.Subtitles[i];

                _playlist.AddAsync(media);
            }
            _playlist.Width = pl.Size.Width;
            _playlist.Height = pl.Size.Height;
            _playlist.CurrentIndex = pl.Current;
            _playlist.SelectedIndex = pl.Current;
            _playlist.Margin = new Thickness(pl.Position.X, pl.Position.Y, 0, 0);
            _playlist.Visibility = pl.SubtitleVisible ? Visibility.Visible : Visibility.Hidden;

            this.WriteLine($"Playlist config was read succesfull");
        }
        catch (Exception ex)
        {
            this.WriteLine($"{ex.Message}");
        }
    }

    /// <summary>
    /// Saves the current playlist configuration to JSON file.
    /// </summary>
    public void SavePlaylistConfig()
    {
        var pl = new Configuration.PlaylistConfig();
        pl.Repeat = (string)_controlBar._repeatComboBox.SelectedItem;
        pl.AutoPlay = true;
        pl.EnableShuffle = true;
        foreach (var item in this.Playlist.Videos)
        {
            // Support both local paths and network URLs by saving the original URI string
            pl.MediaList.Add(item.Uri.OriginalString);
            pl.Subtitles.Add((item.SubtitlePath != null) ? item.SubtitlePath : null);
        }
        pl.Size = new Size(Playlist.Width, Playlist.Height);
        pl.Current = _playlist.CurrentIndex;
        pl.Position = new Point(Playlist.Margin.Left, Playlist.Margin.Top);
        Configuration.Config.SaveToFile("config/playlist.json", pl);

        this.WriteLine($"Save playlist in config/playlist.json");
    }

    /// <summary>
    /// Applies a grayscale effect to the specified image.
    /// </summary>
    /// <param name="image">The image to apply the effect to.</param>
    public void ApplyGrayscaleEffect(Image image)
    {
        // Tworzenie bitmapy na podstawie wymiarï¿½w odtwarzacza
        WriteableBitmap bitmap = new WriteableBitmap((int)image.Width, (int)image.Height, 96, 96, PixelFormats.Bgra32, BitmapPalettes.Gray256Transparent);

        // Przykï¿½adowa modyfikacja pikseli (np. konwersja do szaroï¿½ci)
        bitmap.Lock();
        unsafe
        {
            byte* pixels = (byte*)bitmap.BackBuffer;
            for (int y = 0; y < bitmap.PixelHeight; y++)
            {
                for (int x = 0; x < bitmap.PixelWidth; x++)
                {
                    int index = (y * bitmap.BackBufferStride) + (x * 4); // BGRA: 4 bajty na piksel
                    byte gray = (byte)((pixels[index + 2] + pixels[index + 1] + pixels[index]) / 3); // ï¿½rednia RGB -> szary
                    pixels[index] = gray;     // B
                    pixels[index + 1] = gray; // G
                    pixels[index + 2] = gray; // R
                                              // pixels[index + 3] = alfa (pozostawiamy bez zmian)
                }
            }
        }
        bitmap.AddDirtyRect(new Int32Rect(0, 0, bitmap.PixelWidth, bitmap.PixelHeight));
        bitmap.Unlock();

        // Przypisanie do kontrolki Image w XAML
        image.Source = bitmap;
    }

    /// <summary>
    /// Captures the current video frame as a BitmapSource.
    /// </summary>
    /// <returns>The captured frame or null if capture fails.</returns>
    public BitmapSource GetCurrentFrame()
    {
        /*if (_mediaPlayer == null || !_mediaPlayer.IsPlaying)
        {
            return null; // Brak danych, jeÅ›li nie odtwarza
        }

        try
        {
            using (var ms = new MemoryStream())
            {
                // Pobranie rozmiaru okna wideo
                //var windowSize = _videoView.Width;
                uint actualWidth = (uint)Math.Round(_videoView.Width);  // Konwersja double na int z zaokrÄ…gleniem
                uint height = (uint)Math.Round(_videoView.Height); // Konwersja double na int z zaokrÄ…gleniem

                // Walidacja rozmiaru
                if (actualWidth <= 0 || height <= 0)
                {
                    System.Diagnostics.Debug.WriteLine("NieprawidÅ‚owy rozmiar okna wideo.");
                    return null;
                }

                // Pobranie snapshotu do strumienia
                var result = _mediaPlayer.TakeSnapshot(
                    (uint)_mediaPlayer.Hwnd,          // StrumieÅ„ do zapisu
                    null,
                    (uint)actualWidth,       // SzerokoÅ›Ä‡ w pikselach
                    (uint)height       // WysokoÅ›Ä‡ w pikselach
                );

                if (!result)
                {
                    System.Diagnostics.Debug.WriteLine($"BÅ‚Ä…d pobierania snapshotu, kod: {result}");
                    return null;
                }

                // PrzywrÃ³cenie pozycji strumienia na poczÄ…tek
                ms.Seek(0, SeekOrigin.Begin);

                // Utworzenie BitmapSource z danych strumienia
                var bitmapFrame = BitmapFrame.Create(
                    ms,
                    BitmapCreateOptions.None,
                    BitmapCacheOption.OnLoad
                );
                _image.Source = bitmapFrame;
                return bitmapFrame;
            }*/
        if (_mediaPlayer.IsPlaying)
        {
            // Opcje: szerokoÅ›Ä‡, wysokoÅ›Ä‡, Å›cieÅ¼ka (domyÅ›lnie bieÅ¼Ä…cy katalog), format (png/jpg)
            var result = _playlist.Current.FrameSize.Split('x');
            var width = uint.Parse(result[0]);
            var height = uint.Parse(result[1]);
            bool success = _mediaPlayer.TakeSnapshot(0, null, width, height);

            if (success)
            {
                MessageBox.Show("Klatka przrekazana ");
            }
            else
            {
                MessageBox.Show("BÅ‚Ä…d przechwytywania â€“ sprawdÅº, czy wideo jest odtwarzane.");
            }
            /*
        }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"BÅ‚Ä…d pobierania klatki: {ex.Message}");
                return null;
            }*/
        }
        return null;
    }

    #region Mouse events
    /// <summary>
    /// Background worker method to handle mouse inactivity and hide controls after a delay.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The event arguments.</param>
    private async void MouseNotMoveWorker_DoWork(object sender, DoWorkEventArgs e)
    {
        bool val = true;
        while (val)
        {
            await IfMouseMoved();
            if (e.Cancel)
            {
                val = false;
            }
        }
    }

    /// <summary>
    /// Checks if the mouse has moved during the sleep delay and hides controls if not.
    /// </summary>
    /// <returns>A task representing the asynchronous operation.</returns>
    private async Task<bool> IfMouseMoved()
    {
        _videoView.MouseMove += MouseMovedCallback;
        bool isMouseMove;
        try
        {
            await Task.Delay(TimeSpan.FromSeconds(MouseSleeps));
            isMouseMove = _isMouseMove;
        }
        finally
        {
            _videoView.MouseMove -= MouseMovedCallback;
            await _videoView.Dispatcher.InvokeAsync((Func<Task>)async delegate
            {
                await ControlBar.HideByStoryboard((Storyboard)ControlBar.FindResource("fadeOutControlBar"));
                await ProgressBar.HideByStoryboard((Storyboard)ProgressBar.FindResource("fadeOutProgressBar"));
                _videoView.Cursor = Cursors.None;
            });
            _isMouseMove = false;
        }
        return isMouseMove;
        void MouseMovedCallback(object sender, MouseEventArgs e)
        {
            _isMouseMove = true;
            // and run protected override async void OnMouseMove
        }
    }

    /// <summary>
    /// Handles mouse move events to show controls and set cursor.
    /// </summary>
    /// <param name="e">The mouse event arguments.</param>
    protected override async void OnMouseMove(MouseEventArgs e)
    {
        await ControlBar.ShowByStoryboard((Storyboard)ControlBar.FindResource("fadeInControlBar"));
        await ProgressBar.ShowByStoryboard((Storyboard)ProgressBar.FindResource("fadeInProgressBar"));
        _videoView.Cursor = Cursors.Arrow;
    }

    /// <summary>
    /// Handles double-click to toggle fullscreen mode.
    /// </summary>
    /// <param name="e">The mouse button event arguments.</param>
    protected override void OnMouseDoubleClick(MouseButtonEventArgs e)
    {
        if (e.ChangedButton == MouseButton.Left)
        {
            // Double-click to toggle fullscreen
            Fullscreen = !Fullscreen;
        }
        base.OnMouseDoubleClick(e);
    }


    [NonSerialized]
    private DateTime _lastClickTime = DateTime.MinValue;
    [NonSerialized]
    private Point _lastClickPosition;
    /// <summary>
    /// Handles left mouse button down events, including double-click detection and play/pause toggle.
    /// </summary>
    /// <param name="e">The mouse button event arguments.</param>
    protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e)
    {
        DateTime now = DateTime.Now;
        Point pos = e.GetPosition(this);
        if ((now - _lastClickTime).TotalMilliseconds < System.Windows.Forms.SystemInformation.DoubleClickTime &&
            Math.Abs(pos.X - _lastClickPosition.X) <= 4 &&
            Math.Abs(pos.Y - _lastClickPosition.Y) <= 4)
        {
            OnMouseDoubleClick(e);
            e.Handled = true;
        }

        if (e.ChangedButton == MouseButton.Right)
            TogglePlaylist()();
        else if (e.ChangedButton == MouseButton.Left)
            TogglePlayPause()();

        _lastClickTime = now;
        _lastClickPosition = pos;

        base.OnMouseLeftButtonDown(e);
    }

    /// <summary>
    /// Handles mouse wheel events to adjust volume.
    /// </summary>
    /// <param name="e">The mouse wheel event arguments.</param>
    protected override void OnMouseWheel(MouseWheelEventArgs e)
    {
        base.OnMouseWheel(e);
        // Adjust volume with mouse wheel
        double volumeChange = e.Delta > 0 ? 5.0 : -5.0;
        Volume += volumeChange;
        _controlBar.SliderVolume.Value = Volume;
        _progressBar.PopupText = $"Volume: {(int)Volume}";
        _progressBar._popup.IsOpen = true;

        // Show popup briefly
        Task.Delay(1000).ContinueWith(_ => Dispatcher.Invoke(() => _progressBar._popup.IsOpen = false));
    }
    #endregion

    #region Keybord events
    /// <summary>
    /// Handles key down events for media control shortcuts.
    /// </summary>
    /// <param name="e">The key event arguments.</param>
    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);
        var keyBindingList = new List<ShortcutKeyBinding>
            {
                new ShortcutKeyBinding { MainKey = Key.Space, ModifierKey = null, Shortcut = "Space", Description = "Pause and play media", RunAction = TogglePlayPause() },
                new ShortcutKeyBinding { MainKey = Key.F, ModifierKey = null, Shortcut = "F", Description = "Toggle fullscreen", RunAction = ToggleFullscreen() },
                new ShortcutKeyBinding { MainKey = Key.H, ModifierKey = null, Shortcut = "H", Description = "Toggle help window", RunAction = ToggleHelpWindow() },
                new ShortcutKeyBinding { MainKey = Key.P, ModifierKey = null, Shortcut = "P", Description = "Toggle playlist", RunAction = TogglePlaylist() },
                new ShortcutKeyBinding { MainKey = Key.S, ModifierKey = null, Shortcut = "S", Description = "Toggle subtitle", RunAction = ToggleSubtitle() },
                new ShortcutKeyBinding { MainKey = Key.Left, ModifierKey = null, Shortcut = "Left", Description = "Move media backward 5 seconds", RunAction = () => Seek(TimeSpan.FromSeconds(5), SeekDirection.Backward) },
                new ShortcutKeyBinding { MainKey = Key.Right, ModifierKey = null, Shortcut = "Right", Description = "Move media forward 5 seconds", RunAction = () => Seek(TimeSpan.FromSeconds(5), SeekDirection.Forward) },
                new ShortcutKeyBinding { MainKey = Key.Left, ModifierKey = ModifierKeys.Control, Shortcut = "Ctrl+Left", Description = "Move media backward 5 minutes", RunAction = MoveBackwardMinutes() },
                new ShortcutKeyBinding { MainKey = Key.Right, ModifierKey = ModifierKeys.Control, Shortcut = "Ctrl+Right", Description = "Move media forward 5 minutes", RunAction = MoveForwardMinutes() },
                new ShortcutKeyBinding { MainKey = Key.Up, ModifierKey = null, Shortcut = "Up", Description = "Increase volume by 2", RunAction = () => Volume += 2 },
                new ShortcutKeyBinding { MainKey = Key.Down, ModifierKey = null, Shortcut = "Down", Description = "Decrease volume by 2", RunAction = () => Volume -= 2 },
                new ShortcutKeyBinding { MainKey = Key.M, ModifierKey = null, Shortcut = "M", Description = "Toggle mute_txt", RunAction = () => isMute = !isMute },
                new ShortcutKeyBinding { MainKey = Key.L, ModifierKey = null, Shortcut = "L", Description = "Toggle lector if subtitles are available", RunAction = ToggleLector() },
                new ShortcutKeyBinding { MainKey = Key.Escape, ModifierKey = null, Shortcut = "Esc", Description = "Clear focus, minimize fullscreen", RunAction = ClearFocus() },
                new ShortcutKeyBinding { MainKey = Key.N, ModifierKey = null, Shortcut = "N", Description = "Play next video", RunAction = () => Next() },
                new ShortcutKeyBinding { MainKey = Key.P, ModifierKey = ModifierKeys.Control, Shortcut = "Ctrl+P", Description = "Play previous video", RunAction = () => Preview() },
            };

        foreach (var key in keyBindingList)
        {
            if (e.Key == key.MainKey && key.ModifierKey == null && e.IsDown)
            {
                key.RunAction();
            }
            else if (e.Key == key.MainKey && key.ModifierKey == Keyboard.Modifiers && e.IsDown)
            {
                key.RunAction();
            }
        }

        if (e.IsDown)
        {
            if (Keyboard.Modifiers == ModifierKeys.None)
            {
                this.WriteLine($"Pressed: {e.Key}");
            }
            else
                this.WriteLine($"Pressed: [{Keyboard.Modifiers}]+ {e.Key}");

        }
    }

    /// <summary>
    /// Handles key up events.
    /// </summary>
    /// <param name="e">The key event arguments.</param>
    protected override void OnKeyUp(KeyEventArgs e)
    {
        base.OnKeyUp(e);
        // Handle key release if needed
    }
    #endregion

    #region Actions
    /// <summary>
    /// Toggles subtitle visibility and opens subtitle file if hidden.
    /// </summary>
    /// <returns>An action to toggle subtitles.</returns>
    private Action ToggleSubtitle()
    {
        return new Action(() =>
        {
            if (SubtitleVisibility == Visibility.Visible)
            {
                SubtitleVisibility = Visibility.Hidden;
            }
            else
            {
                OpenSubtitleFile();
            }
        });
    }

    /// <summary>
    /// Toggles lector functionality (placeholder).
    /// </summary>
    /// <returns>An action to toggle lector.</returns>
    private Action ToggleLector()
    {
        return new Action(() =>
        {
            // Placeholder for lector toggle functionality
            Console.WriteLine("[VlcPlayerView]: Toggling lector (not implemented)");
        });
    }

    /// <summary>
    /// Clears focus on the player.
    /// </summary>
    /// <returns>An action to clear focus.</returns>
    private Action ClearFocus()
    {
        return new Action(() =>
        {
            this.Focus();
        });
    }

    /// <summary>
    /// Toggles play/pause or starts playback if stopped.
    /// </summary>
    /// <returns>An action to toggle play/pause.</returns>
    private Action TogglePlayPause()
    {
        return new Action(() =>
        {
            if (isPlaying)
            {
                Pause();
            }
            else if (isPaused)
            {
                Play();
            }
            else if (!isPlaying)
            {
                Play(_playlist.Current);
            }
        });
    }

    /// <summary>
    /// Toggles url view controler show or hide
    /// </summary>
    /// <returns>Visible or Hidden</returns>
    public Action ToggleStreamUrl()
    {
        return new Action(() =>
        {
            //if (_addStreamView.Visibility == Visibility.Visible)
               // _addStreamView.Visibility = Visibility.Hidden;
            //else
               // _addStreamView.Visibility = Visibility.Visible;
        });
    }

    /// <summary>
    /// Toggles fullscreen mode.
    /// </summary>
    /// <returns>An action to toggle fullscreen.</returns>
    private Action ToggleFullscreen()
    {
        return new Action(() =>
        {
            _videoView.Background = Brushes.Black;
            _fullscreen = ScreenHelper.IsFullscreen;
        });
    }

    /// <summary>
    /// Toggles help window (placeholder).
    /// </summary>
    /// <returns>An action to toggle help window.</returns>
    private Action ToggleHelpWindow()
    {
        return new Action(() =>
        {
            // Placeholder for help window toggle
            Console.WriteLine("[VlcPlayerView]: Toggling help window (not implemented)");
        });
    }

    /// <summary>
    /// Toggles playlist visibility.
    /// </summary>
    /// <returns>An action to toggle playlist.</returns>
    private Action TogglePlaylist()
    {
        return new Action(() =>
        {
            if (Playlist.Visibility == Visibility.Visible)
            {
                Playlist.Visibility = Visibility.Hidden;
            }
            else
            {
                Playlist.Visibility = Visibility.Visible;
            }
        });
    }

    /// <summary>
    /// Seeks forward by 5 minutes.
    /// </summary>
    /// <returns>An action to move forward 5 minutes.</returns>
    private Action MoveForwardMinutes()
    {
        return new Action(() =>
        {
            Seek(TimeSpan.FromMinutes(5), SeekDirection.Forward);
        });
    }

    /// <summary>
    /// Seeks backward by 5 minutes.
    /// </summary>
    /// <returns>An action to move backward 5 minutes.</returns>
    private Action MoveBackwardMinutes()
    {
        return new Action(() =>
        {
            Seek(TimeSpan.FromMinutes(5), SeekDirection.Backward);
        });
    }
    #endregion

    #region ControlBar -> SliderVolume -> Mouse Events

    /// <summary>
    /// Handles mouse move on volume slider to update volume preview.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The mouse event arguments.</param>
    private void ControlBar_SliderVolume_MouseMove(object sender, MouseEventArgs e)
    {
        if (DesignerProperties.GetIsInDesignMode(this))
            return;

        Point mousePosition = e.GetPosition(_controlBar.SliderVolume);
        double width = _controlBar.SliderVolume.ActualWidth;
        if (width <= 0) return;

        double position = mousePosition.X / width * _controlBar.SliderVolume.Maximum;

        if (e.LeftButton == MouseButtonState.Pressed)
        {
            _volume = position;
            _controlBar.SliderVolume.Value = position;
        }
    }

    /// <summary>
    /// Handles mouse down on volume slider.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The mouse button event arguments.</param>
    private void ControlBar_SliderVolume_MouseDown(object sender, MouseButtonEventArgs e)
    {
        ControlBar_SliderVolume_MouseEventHandler(sender, e);
    }

    /// <summary>
    /// Common handler for volume slider mouse events.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The mouse event arguments.</param>
    private void ControlBar_SliderVolume_MouseEventHandler(object sender, MouseEventArgs e)
    {
        if (DesignerProperties.GetIsInDesignMode(this))
            return;

        Point mousePosition = e.GetPosition(_controlBar.SliderVolume);
        double width = _controlBar.SliderVolume.ActualWidth;
        if (width <= 0) return;

        double position = mousePosition.X / width * _controlBar.SliderVolume.Maximum;

        _volume = position;
        _controlBar.SliderVolume.Value = position;
    }
    #endregion

    #region MediaPlayer Events
    /// <summary>
    /// Handles volume change events from the media player.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The volume changed event arguments.</param>
    private void OnVolumeChanged(object sender, MediaPlayerVolumeChangedEventArgs e)
    {

    }

    /// <summary>
    /// Subscribes to the playing event.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The event arguments.</param>
    private void MediaPlayer_Playing(object sender, EventArgs e)
    {
        if (Playing != null)
        {
            _mediaPlayer.Playing += (sender, e) =>
            {
                Playing?.Invoke(sender, e);
            };
        }
    }

    /// <summary>
    /// Subscribes to the stopped event.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The event arguments.</param>
    private void MediaPlayer_Stopped(object sender, EventArgs e)
    {
        if (Stopped != null)
        {
            _mediaPlayer.Stopped += (sender, e) =>
            {
                Stopped?.Invoke(sender, e);
            };
        }
    }

    /// <summary>
    /// Subscribes to the time changed event.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The media changed event arguments.</param>
    private void MediaPlayer_TimeChanged(object sender, MediaPlayerMediaChangedEventArgs e)
    {
        if (TimeChanged != null)
        {
            _mediaPlayer.TimeChanged += (sender, e) =>
            {
                TimeChanged?.Invoke(sender, e);
            };
        }
    }

    /// <summary>
    /// Subscribes to the length changed event.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The length changed event arguments.</param>
    private void MediaPlayer_LenghtChanges(object sender, MediaPlayerLengthChangedEventArgs e)
    {
        if (LengthChanged != null)
        {
            _mediaPlayer.LengthChanged += (sender, e) =>
            {
                LengthChanged?.Invoke(sender, e);
            };
        }
    }

    /// <summary>
    /// Handles end of media playback and manages repeat behavior.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The event arguments.</param>
    private void OnEndReached(object sender, EventArgs e)
    {
        _videoView.Dispatcher.InvokeAsync(() =>
        {
            ThreadPool.QueueUserWorkItem(delegate
            {
                Stop();
            });
            var repeat = ControlBar.RepeatMode;
            HandleRepeat(repeat);
        });
    }

    /// <summary>
    /// Handles media change events.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The media changed event arguments.</param>
    private void OnMediaChanged(object sender, MediaPlayerMediaChangedEventArgs e)
    {

    }

    /// <summary>
    /// Updates UI elements with current playback time and progress.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The time changed event arguments.</param>
    private void OnTimeChanged(object sender, MediaPlayerTimeChangedEventArgs e)
    {
        _videoView.Dispatcher.InvokeAsync(() =>
        {
            _playlist.Current.Position = e.Time;

            _progressBar.Value = e.Time;
            _progressBar.Duration = _playlist.Current.Duration;
            _progressBar.ProgressText = string.Format("{0:00} : {1:00} : {2:00} / {3}", TimeSpan.FromMilliseconds(e.Time).Hours, TimeSpan.FromMilliseconds(e.Time).Minutes, TimeSpan.FromMilliseconds(e.Time).Seconds, ProgressBar.Duration.ToString("hh\\:mm\\:ss"));

            _controlBar.MediaTitle = _playlist.Current.Name;
            _controlBar.Position = TimeSpan.FromMilliseconds(e.Time).ToString("hh\\:mm\\:ss");
            _controlBar.Duration = _playlist.Current.Duration.ToString("hh\\:mm\\:ss");
            _subtitleControl.PositionTime = TimeSpan.FromMilliseconds(e.Time);
        });
    }
    #endregion


    /// <summary>
    /// Handles mouse move on progress bar to preview seek position.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The mouse event arguments.</param>
    private void ProgressBar_MouseMove(object sender, MouseEventArgs e)
    {
        if (DesignerProperties.GetIsInDesignMode(this))
            return;

        Point mousePosition = e.GetPosition(_progressBar);
        double actualWidth = _progressBar.ActualWidth;
        if (actualWidth <= 0) return;

        var time = TimeToPositionConverter.Convert(mousePosition.X, actualWidth, _progressBar._progressBar.Maximum);
        _progressBar.PopupText = $"{time.Hours:00}:{time.Minutes:00}:{time.Seconds:00}";
        _progressBar._popup.IsOpen = true;
        _progressBar._popup.HorizontalOffset = mousePosition.X - (_progressBar._popupText.ActualWidth / 2);

        _progressBar._rectangleMouseOverPoint.Margin = new Thickness(mousePosition.X - (_progressBar._rectangleMouseOverPoint.Width / 2), 0, 0, 0);

        if (e.LeftButton == MouseButtonState.Pressed)
        {
            this.Position = time;
        }
    }

    /// <summary>
    /// Handles mouse down on progress bar to seek.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The mouse button event arguments.</param>
    private void ProgressBar_MouseDown(object sender, MouseButtonEventArgs e)
    {
        ProgressBarMouseEventHandler(sender, e);
    }

    /// <summary>
    /// Common handler for progress bar mouse events to perform seeking.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The mouse event arguments.</param>
    private void ProgressBarMouseEventHandler(object sender, MouseEventArgs e)
    {
        if (DesignerProperties.GetIsInDesignMode(this))
            return;

        Point mousePosition = e.GetPosition(_progressBar);
        double width = _progressBar.ActualWidth;
        if (width <= 0) return;

        // Calculate the corresponding time from the mouse position using the forward converter
        var time = TimeToPositionConverter.Convert(mousePosition.X, width, _progressBar._progressBar.Maximum);

        // Set the progress bar value to the milliseconds (as long) and seek the player
        _progressBar.Value = (long)time.TotalMilliseconds;
        this.Position = time;

        // Update the visual indicator for the mouse position
        _progressBar._rectangleMouseOverPoint.Margin = new Thickness(mousePosition.X - (_progressBar._rectangleMouseOverPoint.Width / 2), 0, 0, 0);
    }

    /// <summary>
    /// Sets up event handlers for control bar buttons.
    /// </summary>
    private void ControlBarButtonEvent()
    {
        ControlBar.BtnPlay.Click += delegate
        {
            TogglePlayPause()();
        };
        ControlBar.BtnStop.Click += delegate
        {
            Stop();
        };
        ControlBar.BtnNext.Click += delegate
        {
            Next();
        };
        ControlBar.BtnPrevious.Click += delegate
        {
            Preview();
        };
        ControlBar.BtnMute.Click += delegate
        {
            var mute_txt = String.Empty;

            if (_mediaPlayer.Mute)
                mute_txt = "On";
            else
                mute_txt = "Off";



            _volume = _mediaPlayer.Volume;
            isMute = !isMute;
        };
        ControlBar.BtnOpen.Click += delegate
        {
            OpenMediaFile();
        };
        // Assuming a BtnStream button exists in ControlBar for network streams
        ControlBar.BtnStream.Click += delegate
        {
            ToggleStreamUrl();

            //if (!_addStreamView._addButton.IsCancel)
            //{
            //    OpenNetworkStream(_addStreamView.ReturnUrl);
            //    _addStreamView.Visibility = Visibility.Hidden;
            //}
        };
        ControlBar.BtnPlaylist.Click += delegate
        {
            if (Playlist.Visibility == Visibility.Visible)
            {
                Playlist.Visibility = Visibility.Hidden;
            }
            else
            {
                Playlist.Visibility = Visibility.Visible;
            }
        };
        ControlBar.BtnSubtitle.Click += delegate
        {
            OpenSubtitleFile();
            SubtitleVisibility = Visibility.Visible;
        };
    }

    /// <summary>
    /// Opens a file dialog to select and add media files to the playlist.
    /// </summary>
    private async void OpenMediaFile()
    {
        OpenFileDialog openFileDialog = new OpenFileDialog
        {
            Filter = "VideoItem files|*.mp4;*.mkv;*.avi;*.mov;*.flv;*.wmv|All files|*.*",
            Multiselect = true
        };
        if (openFileDialog.ShowDialog() == true)
        {
            foreach (string path in openFileDialog.FileNames)
            {
                await Playlist.AddAsync(new VideoItem(path));
            }
        }
    }

    /// <summary>
    /// Opens a dialog to input a network stream URL and adds it to the playlist.
    /// Supports HTTP, RTSP, and other streaming protocols via LibVLCSharp.
    /// </summary>
    private async void OpenNetworkStream(string url)
    {
        //string url = Interaction.InputBox("Enter the URL of the network stream (e.g., http://example.com/stream.m3u8 or rtsp://example.com/stream):", "Open Network Stream", "http://");
        
        if (!string.IsNullOrWhiteSpace(url))
        {
            try
            {
                // Validate and create URI
                var uri = new Uri(url, UriKind.Absolute);
                var videoItem = new VideoItem(uri.ToString()); // Use string constructor to set Uri
                videoItem.Name = uri.Host; // Set a simple name based on host
                await Playlist.AddAsync(videoItem);
                // Automatically play the stream
                Play(videoItem);
                this.WriteLine($"Added and playing network stream: {url}");
            }
            catch (UriFormatException ex)
            {
                MessageBox.Show($"Invalid URL format: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error adding stream: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
    }

    /// <summary>
    /// Opens a file dialog to select subtitle files.
    /// </summary>
    private void OpenSubtitleFile()
    {
        OpenFileDialog openFileDialog = new OpenFileDialog
        {
            Filter = "SetSubtitle files|*.txt;*.sub;*.srt|All files|*.*",
            Multiselect = true
        };
        if (openFileDialog.ShowDialog() == true)
        {
            foreach (string path in openFileDialog.FileNames)
            {
                SetSubtitle(path);
                _subtitleVisibility = Visibility.Visible;
            }
        }
    }

    /// <summary>
    /// Sets the subtitle file path and enables AI translation.
    /// </summary>
    /// <param name="path">The path to the subtitle file.</param>
    public void SetSubtitle(string path)
    {
        _videoView.Dispatcher.InvokeAsync(() =>
        {
            _subtitleControl.FilePath = path;
            _subtitleControl.EnableAiTranslation = true;
            _subtitleControl.TimeChanged += delegate (object sender, TimeSpan time)
            {
                if (_videoView.MediaPlayer != null)
                {
                    _subtitleControl.PositionTime = time;
                }
            };
        });
    }

    /// <summary>
    /// Pauses the current media playback.
    /// </summary>
    public void Pause()
    {
        try
        {
            ThreadPool.QueueUserWorkItem(delegate
            {
                _playing = false;
                _paused = true;
                _stopped = false;
                if (_mediaPlayer.IsPlaying)
                {
                    _mediaPlayer.Pause();
                }
                SetThreadExecutionState(DONT_BLOCK_SLEEP_MODE);
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[VlcPlayerView]: {ex.Message}");
        }
    }

    /// <summary>
    /// Stops the current media playback.
    /// </summary>
    public void Stop()
    {
        try
        {
            ThreadPool.QueueUserWorkItem(delegate
            {
                _playing = false;
                _paused = false;
                _stopped = true;
                _mediaPlayer.Stop();
                SetThreadExecutionState(DONT_BLOCK_SLEEP_MODE);
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[VlcPlayerView]: {ex.Message}");
        }
    }

    /// <summary>
    /// Plays the next item in the playlist.
    /// </summary>
    public void Next()
    {
        Stop();
        Playlist.MoveNext.Play();
    }

    /// <summary>
    /// Plays the previous item in the playlist.
    /// </summary>
    public void Preview()
    {
        Stop();
        Playlist.MovePrevious.Play();
    }

    /// <summary>
    /// Seeks to a specific time position in the media.
    /// </summary>
    /// <param name="time">The time span to seek to.</param>
    public void Seek(TimeSpan time)
    {
        if (_mediaPlayer != null)
        {
            ProgressBar.ShowByStoryboard((Storyboard)ProgressBar.FindResource("fadeInProgressBar")).GetAwaiter();
            _mediaPlayer.Time = (long)time.TotalMilliseconds;
        }
    }

    /// <summary>
    /// Seeks forward or backward by a specified time span.
    /// </summary>
    /// <param name="time">The time span to seek by.</param>
    /// <param name="direction">The seek direction.</param>
    public void Seek(TimeSpan time, SeekDirection direction)
    {
        if (_mediaPlayer != null)
        {
            ProgressBar.ShowByStoryboard((Storyboard)ProgressBar.FindResource("fadeInProgressBar")).GetAwaiter();
            switch (direction)
            {
                case SeekDirection.Forward:
                    this.Position += time;
                    break;
                case SeekDirection.Backward:
                    this.Position -= time;
                    break;
            }
        }
    }

    /// <summary>
    /// Internal method to play media, handling pause resume or new media load.
    /// Supports both local files and network streams via URI.
    /// </summary>
    /// <param name="media">The media item to play, or null to resume current.</param>
    private void _Play(VideoItem media = null)
    {
        if (Playlist.Current == null)
        {
            Console.WriteLine($"[VlcPlayerView]: Playlist is empty or current media is not set.");
            return;
        }

        try
        {
            ThreadPool.QueueUserWorkItem(delegate
            {
                _playing = true;
                _paused = false;
                _stopped = false;

                Dispatcher.Invoke(() =>
                {
                    if (_paused && _mediaPlayer.CanPause && _position > TimeSpan.Zero)
                    {
                        _mediaPlayer.Play();
                    }
                    else if (media != null)
                    {
                        using var vlcMedia = new LibVLCSharp.Shared.Media(_libVLC, media.Uri);

                        if (IsLowResolution(media))
                        {
                            ConfigureRealTimeUpscale(vlcMedia);
                        }

                        _mediaPlayer.Play(vlcMedia);
                    }
                    else
                    {
                        _mediaPlayer.Play();
                    }

                    SetThreadExecutionState(BLOCK_SLEEP_MODE);
                });
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[VlcPlayerView]: Error while playing media: {ex.Message}");
        }
    }

    /// <summary>
    /// Plays a specific media item.
    /// </summary>
    /// <param name="media">The media item to play.</param>
    public void Play(VideoItem media)
    {
        _Play(media);
    }

    /// <summary>
    /// Plays or resumes the current media item.
    /// </summary>
    public void Play()
    {
        if (Playlist.Current == null)
        {
            Console.WriteLine($"[VlcPlayerView]: Playlist is empty or current media is not set.");
            return;
        }
        _Play();
    }

    /// <summary>
    /// Configures real-time upscale options for the media.
    /// </summary>
    /// <param name="media">The media to configure.</param>
    /// <param name="targetWidth">The target width for upscale (default 1920).</param>
    /// <param name="targetHeight">The target height for upscale (default 1080).</param>
    private void ConfigureRealTimeUpscale(LibVLCSharp.Shared.Media media, int targetWidth = 1920, int targetHeight = 1080)
    {
        try
        {
            media.AddOption(":video-filter=scale");
            media.AddOption($":scale-actualWidth={targetWidth}");
            media.AddOption($":scale-height={targetHeight}");
            media.AddOption(":video-filter=hqdn3d");

            this.WriteLine($"Applied real-time upscale to {targetWidth}x{targetHeight} with hqdn3d");
        }
        catch (Exception ex)
        {
            this.WriteLine($"Failed to apply upscale: {ex.Message}");
        }
    }

    /// <summary>
    /// Checks if the media resolution is low enough to warrant upscaling.
    /// </summary>
    /// <param name="media">The media item to check.</param>
    /// <returns>True if resolution is below 1280 width.</returns>
    private bool IsLowResolution(VideoItem media)
    {
        try
        {
            if (media != null && int.TryParse(media.FrameSize.Split('x')[0], out int width))
            {
                this.WriteLine($"Resolution: {media.FrameSize}, try to upscale.");
                return width < 1280;
            }
            return true;
        }
        catch
        {
            Console.WriteLine($"[VlcPlayerView]: Failed to check resolution with mediatoolkit, upscale off");
            return false;
        }
    }

    /// <summary>
    /// Handles repeat mode behavior at end of playback.
    /// </summary>
    /// <param name="repeat">The repeat mode string ("One", "All", "Random").</param>
    private void HandleRepeat(string repeat)
    {
        switch (repeat)
        {
            case "One":
                base.Dispatcher.InvokeAsync(delegate
                {
                    Playlist.Current.Play();
                });
                break;
            case "All":
                base.Dispatcher.InvokeAsync(delegate
                {
                    Next();
                });
                break;
            case "Random":
                base.Dispatcher.InvokeAsync(delegate
                {
                    if (Playlist.Items.Count > 0)
                    {
                        int randomIndex = _random.Next(0, Playlist.Items.Count);
                        if (randomIndex == Playlist.CurrentIndex)
                        {
                            randomIndex = (randomIndex + 1) % Playlist.Items.Count;
                        }
                        Playlist.CurrentIndex = randomIndex;
                        Playlist.Current.Play();
                    }
                    else
                    {
                        Stop();
                    }
                });
                break;
        }
    }

    /// <summary>
    /// Handles playing state to block system sleep.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The event arguments.</param>
    private void OnPlaying(object sender, EventArgs e)
    {
        SetThreadExecutionState(BLOCK_SLEEP_MODE);
    }

    /// <summary>
    /// Handles stopped state to allow system sleep.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The event arguments.</param>
    private void OnStopped(object sender, EventArgs e)
    {
        SetThreadExecutionState(DONT_BLOCK_SLEEP_MODE);
    }

    /// <summary>
    /// Handles paused state to allow system sleep.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The event arguments.</param>
    private void OnPaused(object sender, EventArgs e)
    {
        SetThreadExecutionState(DONT_BLOCK_SLEEP_MODE);
    }

    /// <summary>
    /// Updates buffering progress in the UI.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The buffering event arguments.</param>
    private void OnBuffering(object sender, MediaPlayerBufferingEventArgs e)
    {
        this.Dispatcher.InvokeAsync(() =>
        {
            ProgressBar.BufforBarValue = e.Cache;
        });
    }

    /// <summary>
    /// Initializes UI elements when the control is loaded.
    /// </summary>
    /// <param name="sender">The event sender.</param>
    /// <param name="e">The routed event arguments.</param>
    private void VlcPlayerView_Loaded(object sender, RoutedEventArgs e)
    {
        ProgressBar.Duration = Playlist.Current?.Duration ?? TimeSpan.Zero;
        ProgressBar.Value = (long)0.0;
        ProgressBar.ProgressText = "00 : 00 : 00/00 : 00 : 00";
        ProgressBar.PopupText = "Volume: 100";
        ControlBar.MediaTitle = Playlist.Current?.Name ?? "No video loaded";
    }

    /// <summary>
    /// Raises the PropertyChanged event for a property with value comparison.
    /// </summary>
    /// <typeparam name="T">The type of the property.</typeparam>
    /// <param name="propertyName">The name of the property.</param>
    /// <param name="field">Reference to the backing field.</param>
    /// <param name="value">The new value.</param>
    private void OnPropertyChanged<T>(string propertyName, ref T field, T value)
    {
        if (field != null || value == null)
        {
            if (field == null)
            {
                return;
            }
            object obj = value;
            if (field.Equals(obj))
            {
                return;
            }
        }
        field = value;
        PropertyChanged?.Invoke(field, new PropertyChangedEventArgs(propertyName));
    }

    /// <summary>
    /// Raises the PropertyChanged event for a property.
    /// </summary>
    /// <param name="propertyName">The name of the property.</param>
    protected void OnPropertyChanged(string propertyName)
    {
        if (PropertyChanged != null)
        {
            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Disposes resources and saves configuration.
    /// </summary>
    public void Dispose()
    {
        _mediaPlayer?.Dispose();
        SavePlaylistConfig();
        _libVLC?.Dispose();
        SetThreadExecutionState(DONT_BLOCK_SLEEP_MODE);
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\YoutubeControl.xaml.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using Microsoft.Web.WebView2.Wpf;

namespace Thmd.Controls
{
    /// <summary>
    /// Logika interakcji dla klasy YoutubeControl.xaml
    /// </summary>
    public partial class YoutubeControl : UserControl
    {
        public YoutubeControl()
        {
            InitializeComponent();
        }

            public YoutubeControl(WebView2 webView)
            {
                _webView = webView;
            }

            public async Task InitializeAsync()
            {
                await _webView.EnsureCoreWebView2Async();
            }

            public void LoadVideo(string videoId)
            {
                // YouTube embed URL â€“ bez reklam
                string url = $"https://www.youtube.com/embed/{videoId}?autoplay=1&modestbranding=1&rel=0";
                _webView.Source = new Uri(url);
            }
    }
}
// Version: 0.1.0.95



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\ControlButtons\PlayerButtonsControl.xaml.cs

// Version: 0.1.16.93
using System.Windows.Controls;
using System.Windows.Markup;

namespace Thmd.Controls.ControlButtons;

public partial class PlayerButtonsControl : UserControl
{
	public PlayerButtonsControl()
	{
		InitializeComponent();
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\ControlButtons\PlayerButtonsControlSecondRow.xaml.cs

// Version: 0.1.16.93
using System.Windows.Controls;
using System.Windows.Markup;

namespace Thmd.Controls.ControlButtons;

public partial class PlayerButtonsControlSecondRow : UserControl
{
    public PlayerButtonsControlSecondRow()
	{
		InitializeComponent();
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\ControlButtons\PlayerCloseButtonControl.xaml.cs

// Version: 0.1.16.93
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;

namespace Thmd.Controls.ControlButtons;

public partial class PlayerCloseButtonControl : UserControl
{
	public PlayerCloseButtonControl()
	{
		InitializeComponent();
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\Effects\BeatsEffect.xaml.cs

// Version: 0.1.0.95
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;

using Thmd.Consolas;

namespace Thmd.Controls.Effects
{
    /// <summary>
    /// Logika interakcji dla klasy Beats.xaml
    /// </summary>
    public partial class BeatsEffect : UserControl, INotifyPropertyChanged, IEffect
    {
        private double _time = 0.0;
        private DateTime _lastFrameTime;

        // StaÅ‚e czÄ™stotliwoÅ›ci
        private const double PRIMARY_BEAT_FREQUENCY = 1.8;
        private const double SECONDARY_BEAT_FREQUENCY = 0.9;

        // Event INotifyPropertyChanged (opcjonalny dla DependencyProperties)
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        // DependencyProperty dla tÅ‚a (ImageSource w Twoim kodzie â†’ BackgroundImageSource)
        public static readonly DependencyProperty BackgroundImageSourceProperty =
            DependencyProperty.Register(nameof(BackgroundImageSource), typeof(ImageSource), typeof(BeatsEffect),
                new PropertyMetadata(null, OnBackgroundImageSourceChanged));

        public ImageSource BackgroundImageSource
        {
            get => (ImageSource)GetValue(BackgroundImageSourceProperty);
            set => SetValue(BackgroundImageSourceProperty, value);
        }

        private static void OnBackgroundImageSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is BeatsEffect control)
            {
                // Opcjonalnie: logika po zmianie
            }
        }

        // DependencyProperty dla efektu (ImageSource)
        public static readonly DependencyProperty ImageSourceProperty =
            DependencyProperty.Register(nameof(ImageSource), typeof(ImageSource), typeof(BeatsEffect),
                new PropertyMetadata(null, OnImageSourceChanged));

        public ImageSource ImageSource
        {
            get => (ImageSource)GetValue(ImageSourceProperty);
            set => SetValue(ImageSourceProperty, value);
        }

        private static void OnImageSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is BeatsEffect control && e.NewValue == null)
            {
                // DomyÅ›lna wartoÅ›Ä‡ tylko jeÅ›li null
                control.ImageSource = control.LoadImageFromResource("pack://Thmd:,,,/Image/alien_skeleton.png");
            }
        }

        public BeatsEffect()
        {
            InitializeComponent();
            Name = this.GetType().Name;
            DataContext = this;
            _lastFrameTime = DateTime.Now;
            BackgroundImageSource = LoadImageFromResource("pack://Thmd:,,,/Image/alien_skeleton.png");
            ImageSource = LoadImageFromResource("pack://Thmd:,,,/Image/alien_skeleton.png");
            CompositionTarget.Rendering += CompositionTarget_Rendering;

            // Dynamiczne centrowanie transformÃ³w po zaÅ‚adowaniu
            Loaded += BeatsEffect_Loaded;
        }

        private void BeatsEffect_Loaded(object sender, RoutedEventArgs e)
        {
            UpdateTransformCenters();
        }

        private void UpdateTransformCenters()
        {
            double centerX = ActualWidth / 2;
            double centerY = ActualHeight / 2;
            BeatRotate.CenterX = centerX;
            BeatRotate.CenterY = centerY;
            BeatScale.CenterX = centerX;
            BeatScale.CenterY = centerY;
            BeatSkew.CenterX = centerX;
            BeatSkew.CenterY = centerY;
        }

        // WywoÅ‚aj to teÅ¼ w SizeChanged event, jeÅ›li UserControl zmienia rozmiar
        protected override void OnRenderSizeChanged(SizeChangedInfo sizeInfo)
        {
            base.OnRenderSizeChanged(sizeInfo);
            UpdateTransformCenters();
        }

        // Metoda pomocnicza do Å‚adowania ImageSource z zasobu
        private ImageSource LoadImageFromResource(string resourcePath)
        {
            try
            {
                var uri = new Uri(resourcePath, UriKind.Relative);
                var bitmap = new BitmapImage();
                bitmap.BeginInit();
                bitmap.UriSource = uri;
                bitmap.EndInit();
                return bitmap;
            }
            catch(Exception ex)
            {
                this.WriteLine($"[{ex.HResult}]: {ex.Message}");
                return null; // ObsÅ‚uga bÅ‚Ä™dÃ³w (np. brak pliku)
            }
        }

        private void CompositionTarget_Rendering(object sender, EventArgs e)
        {
            DateTime currentTime = DateTime.Now;
            double deltaTime = (currentTime - _lastFrameTime).TotalSeconds;
            _lastFrameTime = currentTime;
            _time += deltaTime;

            // 1. Pulsowanie (Scale)
            double primaryBeat = Math.Abs(Math.Sin(_time * PRIMARY_BEAT_FREQUENCY * Math.PI));
            double secondaryBeat = Math.Abs(Math.Sin(_time * SECONDARY_BEAT_FREQUENCY * Math.PI));
            double combinedBeat = (primaryBeat * 0.7 + secondaryBeat * 0.3);
            double scaleFactor = 1.0 + Math.Pow(combinedBeat, 1.5) * 0.08;
            BeatScale.ScaleX = scaleFactor;
            BeatScale.ScaleY = scaleFactor;

            // 2. Wibracje (Translate)
            double pulseVibration = Math.Pow(primaryBeat, 3) * 4;
            BeatTranslate.X = Math.Sin(_time * 15) * pulseVibration;
            BeatTranslate.Y = Math.Cos(_time * 18) * pulseVibration;

            // 3. Wyginanie (Skew)
            BeatSkew.AngleX = combinedBeat * 2.5;
            BeatSkew.AngleY = combinedBeat * 1.5;

            // 4. Opacity na elemencie UI (nie na ImageSource!)
            /*if (BeatImageElement != null)
            {
                BeatImageElement.Opacity = 0.8 + combinedBeat * 0.2;
            }*/

            // 5. Rotacja
            BeatRotate.Angle = Math.Sin(_time * PRIMARY_BEAT_FREQUENCY * Math.PI) * 5;
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\Effects\IEffect.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Thmd.Controls.Effects
{
    public interface IEffect
    {
        string Name { get; }
    }
}
// Version: 0.1.0.71



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\Effects\SharpenEffect.cs

// Version: 0.1.14.29
using System;
using System.Drawing;
using System.Windows;
using System.Windows.Media.Effects;

namespace Thmd.Controls.Effects;

public class EnhancedSharpenEffect : ShaderEffect
{
    public static readonly DependencyProperty InputProperty = RegisterPixelShaderSamplerProperty("Input", typeof(EnhancedSharpenEffect), 0);
    public static readonly DependencyProperty SharpenAmountProperty = DependencyProperty.Register("SharpenAmount", typeof(float), typeof(EnhancedSharpenEffect), new PropertyMetadata(1.0f, PixelShaderConstantCallback(0)));
    public static readonly DependencyProperty SmoothAmountProperty = DependencyProperty.Register("SmoothAmount", typeof(float), typeof(EnhancedSharpenEffect), new PropertyMetadata(0.0f, PixelShaderConstantCallback(1)));

    public EnhancedSharpenEffect()
    {
        PixelShader = new PixelShader
        {
            UriSource = new Uri("pack://application:,,,/EnhancedSharpenEffect.ps")
        };
        UpdateShaderValue(InputProperty);
        UpdateShaderValue(SharpenAmountProperty);
        UpdateShaderValue(SmoothAmountProperty);
    }

    public Brush Input
    {
        get => (Brush)GetValue(InputProperty);
        set => SetValue(InputProperty, value);
    }

    public float SharpenAmount
    {
        get => (float)GetValue(SharpenAmountProperty);
        set => SetValue(SharpenAmountProperty, value);
    }

    public float SmoothAmount
    {
        get => (float)GetValue(SmoothAmountProperty);
        set => SetValue(SmoothAmountProperty, value);
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Controls\Enums\TextStyle.cs

namespace Thmd.Controls.Enums
{
    /// <summary>
    /// Defines text style options for the subtitle control.
    /// </summary>
    public enum TextStyle
    {
        /// <summary>
        /// Normal text style with no bold or italic formatting.
        /// </summary>
        Normal,
        /// <summary>
        /// Bold text style.
        /// </summary>
        Bold,
        /// <summary>
        /// Italic text style.
        /// </summary>
        Italic,
        /// <summary>
        /// Combined bold and italic text style.
        /// </summary>
        BoldItalic
    }
}
// Version: 0.1.1.61



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\ArithmeticMultiConverter.cs

using System;
using System.Globalization;
using System.Windows.Data;

// Usage in XAML:
// 
//<TextBlock Text = "{MultiBinding Converter={StaticResource ArithmeticMultiConverter}, 
//                  ConverterParameter='+',
//                  <Binding Path="Price" />,
//                  <Binding Path="Tax" />}"
//              />

/// <summary>
/// Multi-value converter for performing arithmetic operations on two numbers (e.g., addition).
/// </summary>
public class ArithmeticMultiConverter : IMultiValueConverter
{
    /// <summary>
    /// Adds two numeric values.
    /// </summary>
    /// <param name="values">Array: [0] = first number, [1] = second number.</param>
    /// <param name="targetType">Target type (double).</param>
    /// <param name="parameter">Operator: "+" (default), "-" or "*".</param>
    /// <param name="culture">Culture.</param>
    /// <returns>Operation result; 0.0 in case of error.</returns>
    public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
    {
        if (values.Length >= 2 && values[0] is double num1 && values[1] is double num2)
        {
            var op = parameter as string ?? "+";
            return op switch
            {
                "+" => num1 + num2,
                "-" => num1 - num2,
                "*" => num1 * num2,
                _ => num1 + num2
            };
        }
        return 0.0;
    }

    /// <summary>
    /// Reverse conversion is not supported (returns null).
    /// </summary>
    public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
    {
        return null; // For one-way operations
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\BooleanToVisibilityConverter.cs

using System;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

/// <summary>
/// Converts a bool value to Visibility: true = Visible, false = Collapsed.
/// </summary>
public static class BooleanToVisibilityConverter
{
    /// <summary>
    /// Converts bool to Visibility.
    /// </summary>
    /// <param name="value">The bool value to convert.</param>
    /// <param name="targetType">The target type (Visibility).</param>
    /// <param name="parameter">Parameter (unused).</param>
    /// <param name="culture">Culture (unused).</param>
    /// <returns>Visibility.Visible if true, Visibility.Collapsed if false.</returns>
    public static object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
        {
            return boolValue ? Visibility.Visible : Visibility.Collapsed;
        }
        return Visibility.Collapsed;
    }

    /// <summary>
    /// Converts Visibility back to bool (optional).
    /// </summary>
    /// <param name="value">The Visibility value to convert.</param>
    /// <param name="targetType">The target type (bool).</param>
    /// <param name="parameter">Parameter (unused).</param>
    /// <param name="culture">Culture (unused).</param>
    /// <returns>true if Visible, false otherwise.</returns>
    public static object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is Visibility visibility)
        {
            return visibility == Visibility.Visible;
        }
        return false;
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\DateTimeMultiConverter.cs

using System;
using System.Globalization;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Markup;

// Usage in XAML
// First, register the converter in resources (e.g., in App.xaml or window):
//
// <Window.Resources>
//    <local:DateTimeMultiConverter x:Key="DateTimeMultiConverter" />
// </Window.Resources>
//
// Example binding in TextBlock (displays combined DateTime):
// <TextBlock>
//    <TextBlock.Text>
//        <MultiBinding Converter="{StaticResource DateTimeMultiConverter}">
//            <Binding Path="SelectedDate" />  <!-- Source: date -->
//            <Binding Path="SelectedTime" />  <!-- Source: time -->
//        </MultiBinding>
//    </TextBlock.Text>
// </TextBlock>

/// <summary>
/// Multi-value converter that combines DateTime (date) and TimeSpan (time) into one DateTime.
/// Useful for bindings where date and time are stored separately.
/// </summary>
public class DateTimeMultiConverter : IMultiValueConverter
{
    /// <summary>
    /// Converts an array of values (date and time) to a single DateTime.
    /// </summary>
    /// <param name="values">Array of values: [0] = DateTime (date), [1] = TimeSpan (time).</param>
    /// <param name="targetType">Target type (DateTime).</param>
    /// <param name="parameter">Parameter (unused).</param>
    /// <param name="culture">Culture (unused).</param>
    /// <returns>DateTime with combined date and time; DateTime.MinValue in case of error.</returns>
    public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
    {
        if (values.Length >= 2 && values[0] is DateTime date && values[1] is TimeSpan time)
        {
            return date.Date + time; // Combines date with time
        }
        return DateTime.MinValue;
    }

    /// <summary>
    /// Converts DateTime back to an array [DateTime (date), TimeSpan (time)].
    /// </summary>
    /// <param name="value">DateTime to decompose.</param>
    /// <param name="targetTypes">Array of target types (DateTime and TimeSpan).</param>
    /// <param name="parameter">Parameter (unused).</param>
    /// <param name="culture">Culture (unused).</param>
    /// <returns>Array with date and time; null in case of error.</returns>
    public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
    {
        if (value is DateTime dateTime && targetTypes.Length >= 2)
        {
            return new object[] { dateTime.Date, dateTime.TimeOfDay };
        }
        return null;
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\EnumToBooleanConverter.cs

using System;
using System.Globalization;
using System.Windows.Input;

// Usage in XAML:
// First, add the converter to resources (e.g., in App.xaml or window):
//
// <Window.Resources>
//      <local:EnumToBooleanConverter x:Key="EnumToBool" />
// </Window.Resources>
//
// Example with enum Status { Active, Inactive }:
// <CheckBox IsChecked="{Binding CurrentStatus, Converter={StaticResource EnumToBool}, ConverterParameter=Active}"
//          Translate="Active" />

/// <summary>
/// Converts an enum value to bool: true if the enum value matches the parameter.
/// Useful for bindings with checkboxes or radiobuttons based on enums.
/// </summary>
public static class EnumToBooleanConverter
{
    /// <summary>
    /// Converts an enum value to bool.
    /// </summary>
    /// <param name="value">The current enum value to check.</param>
    /// <param name="targetType">The target type (bool).</param>
    /// <param name="parameter">The expected enum value (as string name or enum object).</param>
    /// <param name="culture">Culture (unused).</param>
    /// <returns>true if value == parameter; false otherwise.</returns>
    public static object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value == null || parameter == null)
            return false;

        var enumType = value.GetType();
        if (!enumType.IsEnum)
            return false;

        object expectedValue;
        if (parameter is string paramString)
        {
            if (Enum.IsDefined(enumType, paramString))
            {
                expectedValue = Enum.Parse(enumType, paramString);
            }
            else
            {
                return false;
            }
        }
        else
        {
            expectedValue = parameter;
        }

        return value.Equals(expectedValue);
    }

    /// <summary>
    /// Converts bool back to enum (optional: returns parameter if true).
    /// </summary>
    /// <param name="value">The bool value to convert.</param>
    /// <param name="targetType">The target type (enum).</param>
    /// <param name="parameter">The expected enum value.</param>
    /// <param name="culture">Culture (unused).</param>
    /// <returns>Parameter (enum value) if true; null otherwise.</returns>
    public static object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue && boolValue)
        {
            return parameter;
        }
        return null;
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\InverseBooleanConverter.cs

using System;
using System.Globalization;
using System.Windows.Data;

/// <summary>
/// Inverts a bool value: true becomes false and vice versa.
/// </summary>
public static class InverseBooleanConverter
{
    /// <summary>
    /// Inverts bool.
    /// </summary>
    /// <param name="value">The bool value to invert.</param>
    /// <param name="targetType">Target type (bool).</param>
    /// <param name="parameter">Parameter (unused).</param>
    /// <param name="culture">Culture (unused).</param>
    /// <returns>The inverted bool value.</returns>
    public static object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
        {
            return !boolValue;
        }
        return false;
    }

    /// <summary>
    /// Inverts bool back (same as Convert).
    /// </summary>
    public static object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return Convert(value, targetType, parameter, culture);
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\MathClampConverter.cs

// Version: 0.1.14.6
using System;

namespace Thmd.Converters
{
    /// <summary>
    /// Static math class
    /// </summary>
    public static class MathClampConverter
    {
        /// <summary>
        /// Clamps the specified value to be within the inclusive range defined by the minimum and maximum values.
        /// </summary>
        /// <typeparam name="T">The type of the value, which must implement <see cref="IComparable{T}"/>.</typeparam>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The lower bound of the range.</param>
        /// <param name="max">The upper bound of the range.</param>
        /// <returns>The clamped value, which is the original value if it falls within the range, otherwise the nearest bound.</returns>
        public static T Clamp<T>(T value, T min, T max) where T : IComparable<T>
        {
            if (value.CompareTo(min) < 0) return min;
            if (value.CompareTo(max) > 0) return max;
            return value;
        }

        /// <summary>
        /// Clamps the specified double value to be within the inclusive range defined by the minimum and maximum values.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The lower bound of the range.</param>
        /// <param name="max">The upper bound of the range.</param>
        /// <returns>The clamped value, which is the original value if it falls within the range, otherwise the nearest bound.</returns>
        public static double Clamp(double value, double min, double max)
        {
            return System.Math.Max(min, System.Math.Min(max, value));
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\PercentageConverter.cs

using System;
using System.Globalization;
using System.Windows.Data;

/// <summary>
/// Converts a numeric value (0-1) to a percentage string.
/// </summary>
public static class PercentageConverter
{
    /// <summary>
    /// Converts the value to percentage (e.g., 0.75 â†’ "75%").
    /// </summary>
    /// <param name="value">Numeric value (double).</param>
    /// <param name="targetType">Target type (string).</param>
    /// <param name="parameter">Optional divisor (default 1).</param>
    /// <param name="culture">Culture.</param>
    /// <returns>String with percentages.</returns>
    public static object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is double doubleValue && doubleValue >= 0 && doubleValue <= 1)
        {
            double divisor = parameter is double p ? p : 1.0;
            double percentage = (doubleValue / divisor) * 100;
            return $"{percentage:F0}%";
        }
        return "0%";
    }

    /// <summary>
    /// Converts percentage string back to double (e.g., "50%" â†’ 0.5).
    /// </summary>
    public static object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string strValue)
        {
            if (strValue.EndsWith("%"))
            {
                strValue = strValue.TrimEnd('%');
            }
            if (double.TryParse(strValue, NumberStyles.Any, culture, out double percentage))
            {
                return percentage / 100.0;
            }
        }
        return 0.0;
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\PercentageToWidthConverter.cs

// Version: 0.1.13.81
using System;
using System.Globalization;
using System.Windows.Data;

namespace Thmd.Converters
{
    /// <summary>
    /// Converts between a percentage value and an absolute width based on a total width parameter.
    /// Useful for dynamic sizing in WPF UI elements, such as progress bars or proportional layouts.
    /// </summary>
    public class PercentageToWidthConverter : IValueConverter
    {
        /// <summary>
        /// Converts a percentage value (0-100) to an absolute width in pixels.
        /// </summary>
        /// <param name="value">The percentage value to convert (double).</param>
        /// <param name="targetType">The target type (typically double for width).</param>
        /// <param name="parameter">The total width used for calculation (double).</param>
        /// <param name="culture">The culture information (unused).</param>
        /// <returns>The calculated width; 0.0 if the conversion fails.</returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double percentage && parameter is double totalWidth)
            {
                return percentage * totalWidth / 100.0;
            }
            return 0.0;
        }

        /// <summary>
        /// Converts an absolute width back to a percentage value based on the total width.
        /// </summary>
        /// <param name="value">The absolute width to convert (double).</param>
        /// <param name="targetType">The target type (typically double for percentage).</param>
        /// <param name="parameter">The total width used for calculation (double).</param>
        /// <param name="culture">The culture information (unused).</param>
        /// <returns>The calculated percentage; 0.0 if the conversion fails.</returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double width && parameter is double totalWidth)
            {
                return width * 100.0 / totalWidth;
            }
            return 0.0;
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\StringFormatConverter.cs

using System;
using System.Globalization;
using System.Windows.Data;

/// <summary>
/// Formats a string according to the given pattern (e.g., "{0:C}" for currency).
/// </summary>
public static class StringFormatConverter
{
    /// <summary>
    /// Formats the value according to the parameter (string as format).
    /// </summary>
    /// <param name="value">The value to format (e.g., double).</param>
    /// <param name="targetType">The target type (string).</param>
    /// <param name="parameter">The format pattern (e.g., "C" for currency).</param>
    /// <param name="culture">The culture for formatting.</param>
    /// <returns>The formatted string.</returns>
    public static object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value != null && parameter is string format)
        {
            return string.Format(culture ?? CultureInfo.CurrentCulture, "{0:" + format + "}", value);
        }
        return value?.ToString() ?? string.Empty;
    }

    /// <summary>
    /// Reverse conversion is not supported (returns null).
    /// </summary>
    public static object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return null; // Or parsing implementation if needed
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Converters\TimeToPositionConverter.cs

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Thmd.Converters
{
    /// <summary>
    /// Helper class for converting between position (e.g., on a slider) and time (TimeSpan).
    /// Serves as a converter in WPF bindings, mapping position to time and vice versa.
    /// </summary>
    public static class TimeToPositionConverter
    {
        /// <summary>
        /// Converts a position value (e.g., in pixels) to a TimeSpan representing time.
        /// </summary>
        /// <param name="value">Current position (double).</param>
        /// <param name="totalWidth">Total slider width (double, e.g., in pixels).</param>
        /// <param name="maximumLength">Maximum time length in milliseconds (double).</param>
        /// <returns>TimeSpan corresponding to the position; TimeSpan.Zero in case of error.</returns>
        public static TimeSpan Convert(object value, object totalWidth, object maximumLength)
        {
            if (value is double currentPosition && totalWidth is double width && maximumLength is double length)
            {
                if (width <= 0 || length <= 0)
                    return TimeSpan.Zero;

                var result = (currentPosition / width) * length;
                return TimeSpan.FromMilliseconds(result);
            }
            return TimeSpan.Zero;
        }

        /// <summary>
        /// Converts TimeSpan back to position (e.g., in pixels).
        /// </summary>
        /// <typeparam name="T">Target type (unused in implementation).</typeparam>
        /// <param name="value">Time to convert (TimeSpan).</param>
        /// <param name="totalWidth">Total slider width (double, e.g., in pixels).</param>
        /// <param name="maximumLength">Maximum time length in milliseconds (double).</param>
        /// <param name="targetType">Target type (unused).</param>
        /// <returns>Position as double; 0.0 in case of error.</returns>
        public static object ConvertBack<T>(object value, object totalWidth, object maximumLength, T targetType) where T : class
        {
            if (value is TimeSpan timeSpan && totalWidth is double width && maximumLength is double length)
            {
                if (width <= 0 || length <= 0)
                    return 0.0;

                var ms = timeSpan.TotalMilliseconds;
                var result = (ms / length) * width;
                return result;
            }
            return 0.0;
        }
    }
}
// Version: 0.1.0.15



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Devices\Keyboards\ShortcutKeyBinding.cs

// Version: 0.1.4.29
using System;
using System.Windows.Input;

namespace Thmd.Devices.Keyboards
{
    /// <summary>
    /// 
    /// </summary>
    public class ShortcutKeyBinding
    {
        /// <summary>
        /// 
        /// </summary>
        public Key MainKey { get; set; }
        /// <summary>
        /// 
        /// </summary>
        public Key SecondKey { get; set; }
        /// <summary>
        /// 
        /// </summary>
        public ModifierKeys? ModifierKey { get; set; }
        /// <summary>
        /// 
        /// </summary>
        public string Shortcut { get; set; }
        /// <summary>
        /// 
        /// </summary>
        public string Description { get; set; }
        /// <summary>
        /// 
        /// </summary>
        public Action RunAction { get; set; }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\AsyncLogger.cs

// Version: 0.1.16.93
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace Thmd.Logs;

public class AsyncLogger : IDisposable
{
	private readonly BlockingCollection<LogEntry> _logQueue = new BlockingCollection<LogEntry>(new ConcurrentQueue<LogEntry>());

	private readonly List<ILogSink> _sinks = new List<ILogSink>();

	private readonly CancellationTokenSource _cts = new CancellationTokenSource();

	private readonly Metrics _metrics = new Metrics();

	private readonly int _batchSize = 10;

	private readonly TimeSpan _flushInterval = TimeSpan.FromSeconds(5.0);

	public LogLevel MinLogLevel { get; set; } = LogLevel.Info;

	public Dictionary<string, bool> CategoryFilters { get; } = new Dictionary<string, bool>();

	public AsyncLogger()
	{
		Task.Run(ProcessLogs);
	}

	public void AddSink(ILogSink sink)
	{
		_sinks.Add(sink);
	}

	public void Log(LogLevel level, string category, string message, Exception exception = null)
	{
		if (level >= MinLogLevel && IsCategoryEnabled(category) && _logQueue != null)
		{
			if (_logQueue.IsAddingCompleted)
			{
				Console.WriteLine("Log queue is completed. Cannot add new log entries.");
				return;
			}
			_logQueue.Add(new LogEntry(level, category, message, exception));
			_metrics.IncrementTotalLogs();
		}
	}

	public void Log(LogLevel level, string[] categories, string message, Exception exception = null)
	{
		foreach (string category in categories)
		{
			Log(level, category, message, exception);
		}
	}

	private bool IsCategoryEnabled(string category)
	{
		bool enabled;
		return !CategoryFilters.TryGetValue(category, out enabled) || enabled;
	}

	private async Task ProcessLogs()
	{
		List<LogEntry> batch = new List<LogEntry>();
		DateTime lastFlush = DateTime.UtcNow;
		while (!_cts.IsCancellationRequested)
		{
			try
			{
				LogEntry entry = _logQueue.Take(_cts.Token);
				batch.Add(entry);
				if (batch.Count >= _batchSize || DateTime.UtcNow - lastFlush >= _flushInterval)
				{
					await FlushBatch(batch);
					batch.Clear();
					lastFlush = DateTime.UtcNow;
				}
			}
			catch (OperationCanceledException)
			{
				await FlushBatch(batch);
				break;
			}
		}
	}

	private async Task FlushBatch(List<LogEntry> batch)
	{
		Stopwatch sw = Stopwatch.StartNew();
		try
		{
			foreach (ILogSink sink in _sinks)
			{
				List<LogEntry> filtered = batch.FindAll((e) => sink.AcceptsCategory(e.Category));
				foreach (LogEntry entry in filtered)
				{
					await sink.WriteAsync(entry);
				}
			}
			_metrics.RecordSuccess(sw.Elapsed);
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			_metrics.RecordError(ex2);
		}
	}

	public Metrics GetMetrics()
	{
		return _metrics;
	}

	public void Dispose()
	{
		_cts.Cancel();
		_logQueue.CompleteAdding();
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\CategoryFilterSink.cs

// Version: 0.1.16.93
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Thmd.Logs;

public class CategoryFilterSink : ILogSink
{
	private readonly ILogSink _innerSink;

	private readonly HashSet<string> _allowedCategories;

	public CategoryFilterSink(ILogSink innerSink, IEnumerable<string> allowedCategories)
	{
		_innerSink = innerSink;
		_allowedCategories = new HashSet<string>(allowedCategories);
	}

	public bool AcceptsCategory(string category)
	{
		return _allowedCategories.Contains(category);
	}

	public async Task WriteAsync(LogEntry entry)
	{
		if (AcceptsCategory(entry.Category))
		{
			await _innerSink.WriteAsync(entry);
		}
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\ConsoleSink.cs

// Version: 0.1.16.93
using System;
using System.Threading.Tasks;

namespace Thmd.Logs;

public class ConsoleSink : ILogSink
{
	private readonly ILogFormatter _formatter;

	public ConsoleSink(ILogFormatter formatter = null)
	{
		_formatter = formatter ?? new TextFormatter();
	}

	public bool AcceptsCategory(string category)
	{
		if (category == null)
		{
			return false;
		}
		return true;
	}

	public void Write(LogEntry entry)
	{
		ConsoleColor currentColor = Console.ForegroundColor;
		switch (entry.Level)
		{
		case LogLevel.Debug:
			Console.ForegroundColor = ConsoleColor.Yellow;
			break;
		case LogLevel.Info:
			Console.ForegroundColor = ConsoleColor.Green;
			break;
		case LogLevel.Warning:
			Console.ForegroundColor = ConsoleColor.Blue;
			break;
		case LogLevel.Error:
			Console.ForegroundColor = ConsoleColor.Red;
			break;
		default:
			Console.ForegroundColor = currentColor;
			break;
		}
		Console.WriteLine(_formatter.Format(entry));
	}

	public async Task WriteAsync(LogEntry entry)
	{
		await Task.Run(delegate
		{
			Write(entry);
		});
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\FileSink.cs

// Version: 0.1.16.93
using System;
using System.IO;
using System.Threading.Tasks;

namespace Thmd.Logs;

public class FileSink : ILogSink
{
	private readonly string _logDirectory;

	private readonly string _filePrefix;

	private readonly ILogFormatter _formatter;

	private readonly long _maxFileSize;

	private readonly int _maxRetainedFiles;

	private readonly object _lock = new object();

	private string _currentFilePath;

	public FileSink(string logDirectory = "logs", string filePrefix = "log", ILogFormatter formatter = null, long maxFileSize = 10485760L, int maxRetainedFiles = 5)
	{
		_logDirectory = logDirectory;
		_filePrefix = filePrefix;
		_formatter = formatter ?? new TextFormatter();
		_maxFileSize = maxFileSize;
		_maxRetainedFiles = maxRetainedFiles;
		Directory.CreateDirectory(logDirectory);
		UpdateCurrentFile();
	}

	public void Write(LogEntry entry)
	{
		lock (_lock)
		{
			CheckFileRotation();
			File.AppendAllText(_currentFilePath, _formatter.Format(entry) + Environment.NewLine);
		}
	}

	private void CheckFileRotation()
	{
		FileInfo fileInfo = new FileInfo(_currentFilePath);
		if (fileInfo.Exists && fileInfo.Length > _maxFileSize)
		{
			RotateFiles();
			UpdateCurrentFile();
		}
	}

	private void UpdateCurrentFile()
	{
		_currentFilePath = Path.Combine(_logDirectory, $"{_filePrefix}_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
	}

	private void RotateFiles()
	{
		string[] files = Directory.GetFiles(_logDirectory, _filePrefix + "_*.txt");
		if (files.Length >= _maxRetainedFiles)
		{
			Array.Sort(files);
			for (int i = 0; i < files.Length - _maxRetainedFiles + 1; i++)
			{
				File.Delete(files[i]);
			}
		}
	}

	public async Task WriteAsync(LogEntry entry)
	{
		await Task.Run(delegate
		{
			Write(entry);
		});
	}

	public bool AcceptsCategory(string category)
	{
		if (category == null)
		{
			return false;
		}
		return true;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\ILogFormatter.cs

// Version: 0.1.16.93
namespace Thmd.Logs;

public interface ILogFormatter
{
	string Format(LogEntry entry);
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\ILogSink.cs

// Version: 0.1.16.93
using System.Threading.Tasks;

namespace Thmd.Logs;

public interface ILogSink
{
	Task WriteAsync(LogEntry entry);

	bool AcceptsCategory(string category);
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\JsonFormatter.cs

// Version: 0.1.16.93
using Newtonsoft.Json;

namespace Thmd.Logs;

public class JsonFormatter : ILogFormatter
{
	public string Format(LogEntry entry)
	{
		var logData = new
		{
			entry.Timestamp,
			entry.Level,
			entry.Message,
			Exception = entry.Exception?.Message,
			entry.Exception?.StackTrace
		};
		return JsonConvert.SerializeObject(logData);
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\LogEntry.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Logs;

public class LogEntry
{
	public DateTime Timestamp { get; }

	public LogLevel Level { get; }

	public string Category { get; }

	public string Message { get; }

	public Exception Exception { get; }

	public string Object { get; } = null;

	public LogEntry(LogLevel level, string category, string message, Exception exception = null)
	{
		Timestamp = DateTime.Now;
		Level = level;
		Category = category;
		Message = message;
		Exception = exception;
	}

	public LogEntry(object obj, LogLevel level, string category, string message, Exception exception = null)
	{
		Timestamp = DateTime.Now;
		Level = level;
		Category = category;
		Message = message;
		Exception = exception;
		Object = obj?.ToString();
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\Logger.cs

using System;
using System.Collections.Generic;
using System.IO;
using System.Windows; // For WPF integration, e.g., MessageBox for UI alerts
using System.Threading.Tasks; // For asynchronous logging
using System.Windows.Threading; // For Dispatcher

namespace Thmd.Logs
{
    /// <summary>
    /// Enum representing different levels of logging severity.
    /// </summary>
    public enum LogLevel
    {
        /// <summary>
        /// Debug level
        /// </summary>
        Debug,
        /// <summary>
        /// Info level
        /// </summary>
        Info,
        /// <summary>
        /// Warning level
        /// </summary>
        Warning,
        /// <summary>
        /// Error level
        /// </summary>
        Error,
        /// <summary>
        /// Critical level
        /// </summary>
        Critical
    }

    /// <summary>
    /// Interface defining the contract for log handlers.
    /// Handlers implement this to process log messages.
    /// </summary>
    public interface ILogHandler
    {
        /// <summary>
        /// Logs a message with the specified level and optional exception.
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        void Log(LogLevel level, string message, Exception ex = null);
    }

    /// <summary>
    /// Abstract base class for log handlers providing common functionality
    /// such as minimum level filtering.
    /// </summary>
    public abstract class BaseLogHandler : ILogHandler
    {
        /// <summary>
        /// Gets or sets the minimum log level this handler will process.
        /// </summary>
        protected LogLevel MinimumLevel { get; set; }

        /// <summary>
        /// Initializes a new instance of the BaseLogHandler class.
        /// </summary>
        /// <param name="minLevel">The minimum log level to handle (default: Info).</param>
        protected BaseLogHandler(LogLevel minLevel = LogLevel.Info)
        {
            MinimumLevel = minLevel;
        }

        /// <summary>
        /// Logs a message if the level meets or exceeds the minimum level.
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        public void Log(LogLevel level, string message, Exception ex = null)
        {
            if (level >= MinimumLevel)
            {
                HandleLog(level, message, ex);
            }
        }

        /// <summary>
        /// Abstract method to be implemented by derived handlers for actual logging logic.
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        protected abstract void HandleLog(LogLevel level, string message, Exception ex = null);
    }

    /// <summary>
    /// Console log handler that outputs logs to the console.
    /// </summary>
    public class ConsoleLogHandler : BaseLogHandler
    {
        /// <summary>
        /// Initializes a new instance of the ConsoleLogHandler class.
        /// </summary>
        /// <param name="minLevel">The minimum log level to handle (default: Info).</param>
        public ConsoleLogHandler(LogLevel minLevel = LogLevel.Info) : base(minLevel) { }

        /// <summary>
        /// Handles logging by writing to the console.
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        protected override void HandleLog(LogLevel level, string message, Exception ex = null)
        {
            var logMessage = $"[{DateTime.Now}] [{level}] {message}";
            if (ex != null)
            {
                logMessage += $"\n{ex}";
            }
            Console.WriteLine(logMessage);
        }
    }

    /// <summary>
    /// File log handler that appends logs to a specified file.
    /// </summary>
    public class FileLogHandler : BaseLogHandler
    {
        private readonly string _filePath;
        private readonly object _lock = new object();

        /// <summary>
        /// Initializes a new instance of the FileLogHandler class.
        /// </summary>
        /// <param name="filePath">The path to the log file.</param>
        /// <param name="minLevel">The minimum log level to handle (default: Info).</param>
        public FileLogHandler(string filePath, LogLevel minLevel = LogLevel.Info) : base(minLevel)
        {
            _filePath = filePath;
            EnsureFileExists();
        }

        /// <summary>
        /// Ensures the log file exists and creates the directory if necessary.
        /// </summary>
        private void EnsureFileExists()
        {
            if (!File.Exists(_filePath))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(_filePath) ?? string.Empty);
                File.Create(_filePath).Dispose();
            }
        }

        /// <summary>
        /// Handles logging by appending to the file (thread-safe).
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        protected override void HandleLog(LogLevel level, string message, Exception ex = null)
        {
            lock (_lock)
            {
                using (var writer = File.AppendText(_filePath))
                {
                    var logMessage = $"[{DateTime.Now}] [{level}] {message}";
                    if (ex != null)
                    {
                        logMessage += $"\n{ex}";
                    }
                    writer.WriteLine(logMessage);
                }
            }
        }
    }

    /// <summary>
    /// WPF UI log handler that displays logs via MessageBox for UI thread safety.
    /// </summary>
    public class WpfUiLogHandler : BaseLogHandler
    {
        /// <summary>
        /// Initializes a new instance of the WpfUiLogHandler class.
        /// </summary>
        /// <param name="minLevel">The minimum log level to handle (default: Error).</param>
        public WpfUiLogHandler(LogLevel minLevel = LogLevel.Error) : base(minLevel) { }

        /// <summary>
        /// Handles logging by showing a MessageBox on the UI thread.
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        protected override void HandleLog(LogLevel level, string message, Exception ex = null)
        {
            Application.Current?.Dispatcher.Invoke(() =>
            {
                var fullMessage = $"{message}{(ex != null ? $"\n{ex.Message}\n{ex.StackTrace}" : "")}";
                MessageBox.Show($"[{level}] {fullMessage}", "Log Message", MessageBoxButton.OK, GetMessageBoxImage(level));
            });
        }

        /// <summary>
        /// Gets the appropriate MessageBox image based on the log level.
        /// </summary>
        /// <param name="level">The log level.</param>
        /// <returns>The corresponding MessageBoxImage.</returns>
        private MessageBoxImage GetMessageBoxImage(LogLevel level)
        {
            return level switch
            {
                LogLevel.Warning => MessageBoxImage.Warning,
                LogLevel.Error => MessageBoxImage.Error,
                LogLevel.Critical => MessageBoxImage.Error,
                _ => MessageBoxImage.Information
            };
        }
    }

    /// <summary>
    /// Main singleton Logger class that manages multiple handlers and global settings.
    /// </summary>
    public class Logger
    {
        private static Logger _instance;
        private static readonly object _instanceLock = new object();
        private readonly List<ILogHandler> _handlers = new List<ILogHandler>();
        private LogLevel _globalMinLevel = LogLevel.Info;

        private Logger() { }

        /// <summary>
        /// Gets the singleton instance of the Logger.
        /// </summary>
        public static Logger Instance
        {
            get
            {
                lock (_instanceLock)
                {
                    return _instance ??= new Logger();
                }
            }
        }

        /// <summary>
        /// Adds a log handler to the list of active handlers.
        /// </summary>
        /// <param name="handler">The ILogHandler to add.</param>
        public void AddHandler(ILogHandler handler)
        {
            _handlers.Add(handler);
        }

        /// <summary>
        /// Sets the global minimum log level for all handlers.
        /// </summary>
        /// <param name="level">The new global minimum level.</param>
        public void SetGlobalMinLevel(LogLevel level)
        {
            _globalMinLevel = level;
        }

        /// <summary>
        /// Logs a message synchronously (without exception).
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        public void Log(LogLevel level, string message)
        {
            Log(level, message, null);
        }

        /// <summary>
        /// Logs a message synchronously with optional exception.
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        public void Log(LogLevel level, string message, Exception ex)
        {
            if (level < _globalMinLevel) return;

            foreach (var handler in _handlers)
            {
                handler.Log(level, message, ex);
            }
        }

        /// <summary>
        /// Logs a message asynchronously (without exception).
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task LogAsync(LogLevel level, string message)
        {
            await LogAsync(level, message, null);
        }

        /// <summary>
        /// Logs a message asynchronously with optional exception.
        /// </summary>
        /// <param name="level">The severity level of the log.</param>
        /// <param name="message">The log message.</param>
        /// <param name="ex">Optional exception associated with the log.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task LogAsync(LogLevel level, string message, Exception ex)
        {
            if (level < _globalMinLevel) return;

            await Task.Run(() => Log(level, message, ex));
        }

        // Convenience methods (sync)
        /// <summary>
        /// Logs a debug message synchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        public void Debug(string message) => Log(LogLevel.Debug, message);
        /// <summary>
        /// Logs a debug message synchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        public void Debug(string message, Exception ex) => Log(LogLevel.Debug, message, ex);
        /// <summary>
        /// Logs an info message synchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        public void Info(string message) => Log(LogLevel.Info, message);
        /// <summary>
        /// Logs an info message synchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        public void Info(string message, Exception ex) => Log(LogLevel.Info, message, ex);
        /// <summary>
        /// Logs a warning message synchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        public void Warn(string message) => Log(LogLevel.Warning, message);
        /// <summary>
        /// Logs a warning message synchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        public void Warn(string message, Exception ex) => Log(LogLevel.Warning, message, ex);
        /// <summary>
        /// Logs an error message synchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        public void Error(string message) => Log(LogLevel.Error, message);
        /// <summary>
        /// Logs an error message synchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        public void Error(string message, Exception ex) => Log(LogLevel.Error, message, ex);
        /// <summary>
        /// Logs a critical message synchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        public void Critical(string message) => Log(LogLevel.Critical, message);
        /// <summary>
        /// Logs a critical message synchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        public void Critical(string message, Exception ex) => Log(LogLevel.Critical, message, ex);

        // Simplified async convenience methods
        /// <summary>
        /// Logs a debug message asynchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task DebugAsync(string message) => await LogAsync(LogLevel.Debug, message);
        /// <summary>
        /// Logs a debug message asynchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task DebugAsync(string message, Exception ex) => await LogAsync(LogLevel.Debug, message, ex);
        /// <summary>
        /// Logs an info message asynchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task InfoAsync(string message) => await LogAsync(LogLevel.Info, message);
        /// <summary>
        /// Logs an info message asynchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task InfoAsync(string message, Exception ex) => await LogAsync(LogLevel.Info, message, ex);
        /// <summary>
        /// Logs a warning message asynchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task WarnAsync(string message) => await LogAsync(LogLevel.Warning, message);
        /// <summary>
        /// Logs a warning message asynchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task WarnAsync(string message, Exception ex) => await LogAsync(LogLevel.Warning, message, ex);
        /// <summary>
        /// Logs an error message asynchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task ErrorAsync(string message) => await LogAsync(LogLevel.Error, message);
        /// <summary>
        /// Logs an error message asynchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task ErrorAsync(string message, Exception ex) => await LogAsync(LogLevel.Error, message, ex);
        /// <summary>
        /// Logs a critical message asynchronously (without exception).
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task CriticalAsync(string message) => await LogAsync(LogLevel.Critical, message);
        /// <summary>
        /// Logs a critical message asynchronously with exception.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <param name="ex">The exception.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public async Task CriticalAsync(string message, Exception ex) => await LogAsync(LogLevel.Critical, message, ex);
    }

    // Example usage in a WPF application
    // In App.xaml.cs or MainWindow.xaml.cs:
    // Logger.Instance.AddHandler(new ConsoleLogHandler());
    // Logger.Instance.AddHandler(new FileLogHandler("app.log"));
    // Logger.Instance.AddHandler(new WpfUiLogHandler(LogLevel.Critical));
    // await Logger.Instance.InfoAsync("Application started.");
}
// Version: 0.1.0.3



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\LogLevel.cs

// Version: 0.1.16.93
namespace Thmd.Logs;

public enum LoggerLevel
{
	Debug,
	Info,
	Warning,
	Error
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\Metrics.cs

// Version: 0.1.16.93
using System;
using System.Threading;

namespace Thmd.Logs;

public class Metrics
{
	private int _totalLogs;

	private int _failedWrites;

	private TimeSpan _totalProcessingTime;

	public void IncrementTotalLogs()
	{
		Interlocked.Increment(ref _totalLogs);
	}

	public void RecordError(Exception _)
	{
		Interlocked.Increment(ref _failedWrites);
	}

	public void RecordSuccess(TimeSpan duration)
	{
		_totalProcessingTime += duration;
	}

	public override string ToString()
	{
		return $"Logs: {_totalLogs}, Errors: {_failedWrites}, Avg Time: {_totalProcessingTime.TotalMilliseconds / _totalLogs} ms";
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\TextFormatter.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Logs;

public class TextFormatter : ILogFormatter
{
	public string Format(LogEntry entry)
	{
		ConsoleColor current = Console.ForegroundColor;
		current = ConsoleColor.Gray;
		string logEntry = $"{entry.Timestamp:yyyy-MM-dd HH:mm:ss} {entry.Object} [{entry.Level}] {entry.Message}";
		if (entry.Exception != null)
		{
			logEntry = logEntry + "\nException: " + entry.Exception.Message + "\nStack Trace: " + entry.Exception.StackTrace;
		}
		return logEntry;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Logs\XmlFormatter.cs

// Version: 0.1.16.93
using System.IO;
using System.Xml.Serialization;

namespace Thmd.Logs;

public class XmlFormatter : ILogFormatter
{
	public string Format(LogEntry entry)
	{
		XmlSerializer serializer = new XmlSerializer(typeof(LogEntry));
		using StringWriter writer = new StringWriter();
		serializer.Serialize(writer, entry);
		return writer.ToString();
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\FileMediaStream.cs

// Version: 0.1.16.93
using System;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;

namespace Thmd.Media;

public class FileMediaStream : IMediaStream, IDisposable
{
	private readonly string _filePath;

	private Stream _stream;

	private FileStream _fileStream;

	public FileMediaStream(string path)
	{
		_fileStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
		_filePath = path;
	}

	public async Task<string> DownloadM3U8ContentAsync(string url)
	{
		HttpClient httpClient = new HttpClient();
		try
		{
			return await httpClient.GetStringAsync(url);
		}
		finally
		{
			((IDisposable)httpClient)?.Dispose();
		}
	}

	public Task<Stream> GetStream()
	{
		return Task.FromResult((Stream)File.OpenRead(_filePath));
	}

	public async Task<Stream> GetStreamAsync()
	{
		FileStream stream = File.OpenRead(_filePath);
		byte[] buffer = new byte[stream.Length];
		await stream.ReadAsync(buffer, 0, buffer.Length);
		_stream = new MemoryStream(buffer);
		return stream;
	}

	public double GetDuration()
	{
		return 120.0;
	}

	public void Dispose()
	{
		_fileStream?.Dispose();
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\HlsPlaylistParser.cs

// Version: 0.1.16.93
using System;
using System.Collections.Generic;

namespace Thmd.Media;

public static class HlsPlaylistParser
{
	public static List<HlsSegment> ParsePlaylist(string m3u8Content, Uri baseUri)
	{
		List<HlsSegment> segments = new List<HlsSegment>();
		string[] lines = m3u8Content.Split(new char[1] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
		HlsSegment currentSegment = null;
		string[] array = lines;
		foreach (string line in array)
		{
			string trimmedLine = line.Trim();
			if (trimmedLine.StartsWith("#EXTINF:"))
			{
				currentSegment = new HlsSegment();
				string durationPart = trimmedLine.Split(':')[1].Split(',')[0];
				currentSegment.Duration = TimeSpan.FromMilliseconds(double.Parse(durationPart));
			}
			else if (trimmedLine.StartsWith("#EXT-X-DISCONTINUITY"))
			{
				if (currentSegment != null)
				{
					currentSegment.IsDiscontinuity = true;
				}
			}
			else if (trimmedLine.StartsWith("#"))
			{
				if (currentSegment != null)
				{
					string[] parts = trimmedLine.Split(new char[1] { ':' }, 2);
					if (parts.Length > 1)
					{
						currentSegment.Tags[parts[0]] = parts[1];
					}
				}
			}
			else if (!trimmedLine.StartsWith("#") && currentSegment != null)
			{
				currentSegment.Uri = new Uri(baseUri, trimmedLine).AbsoluteUri;
				segments.Add(currentSegment);
				currentSegment = null;
			}
		}
		return segments;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\HlsSegment.cs

// Version: 0.1.16.93
using System;
using System.Collections.Generic;

namespace Thmd.Media;

public class HlsSegment
{
	public string Title { get; set; }

	public string Description { get; set; }

	public string Url { get; set; }

	public TimeSpan Duration { get; set; }

	public string Uri { get; set; }

	public bool IsDiscontinuity { get; set; }

	public Dictionary<string, string> Tags { get; set; } = new Dictionary<string, string>();
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\HLSStreamer.cs

// Version: 0.1.16.93
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading;
using System.Threading.Tasks;

namespace Thmd.Media;

public class HLSStreamer : IDisposable
{
	private readonly HttpClient _httpClient;

	private CancellationTokenSource _cts;

	private List<HlsSegment> _segments;

	private Uri _playlistUri;

	public event Action<byte[]> SegmentDownloaded;

	public event Action<List<HlsSegment>> PlaylistParsed;

	public event Action<string> ErrorOccurred;

	public event Action StreamEnded;

	public HLSStreamer()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		_httpClient = new HttpClient();
		_httpClient.DefaultRequestHeaders.Add("User-Agent", "HLS-Streamer/1.0");
	}

	public async Task StartStreamingAsync(string m3u8Url, CancellationToken cancellationToken = default)
	{
		try
		{
			_playlistUri = new Uri(m3u8Url);
			_cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
			while (!_cts.IsCancellationRequested)
			{
				_segments = HlsPlaylistParser.ParsePlaylist(await DownloadPlaylistAsync(_playlistUri), _playlistUri);
                PlaylistParsed?.Invoke(_segments);
				foreach (HlsSegment segment in _segments)
				{
					_ = segment;
					if (_cts.IsCancellationRequested)
					{
						break;
					}
					try
					{
						byte[] segmentData = await _httpClient.GetByteArrayAsync(_playlistUri);
                        SegmentDownloaded?.Invoke(segmentData);
					}
					catch (Exception ex)
					{
                        ErrorOccurred?.Invoke("Error downloading segment: " + ex.Message);
					}
				}
				if (_cts.IsCancellationRequested)
				{
					break;
				}
				await Task.Delay(TimeSpan.FromSeconds(_segments.FirstOrDefault()?.Duration.TotalSeconds ?? 10.0), _cts.Token);
			}
            StreamEnded?.Invoke();
		}
		catch (Exception ex2)
		{
			Exception ex3 = ex2;
            ErrorOccurred?.Invoke("Streaming failed: " + ex3.Message);
		}
	}

	public void StopStreaming()
	{
		_cts?.Cancel();
	}

	private async Task<string> DownloadPlaylistAsync(Uri uri)
	{
		try
		{
			return await _httpClient.GetStringAsync(uri);
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
            ErrorOccurred?.Invoke("Playlist download error: " + ex2.Message);
			throw;
		}
	}

	public void Dispose()
	{
		_cts?.Cancel();
		HttpClient httpClient = _httpClient;
		if (httpClient != null)
		{
			httpClient.Dispose();
		}
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\IMedia.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Media;

/// <summary>
///  Interface representing a media item.
/// </summary>
public interface IMedia
{
    /// <summary>
    /// Gets or sets media source.
    /// </summary>
    string Source { get; set; }
    /// <summary>
    /// Gets or sets media title.
    /// </summary>
	string Title { get; set; }
    /// <summary>
    /// Gets media duration.
    /// </summary>
    TimeSpan Duration { get; }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\IMediaStream.cs

// Version: 0.1.16.93
using System;
using System.IO;
using System.Threading.Tasks;

namespace Thmd.Media;

public interface IMediaStream : IDisposable
{
	Task<Stream> GetStreamAsync();

	Task<Stream> GetStream();

	double GetDuration();
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\IPlayer.cs

// Version: 0.1.16.88
using System;
using System.ComponentModel;
using System.Windows;

using Thmd.Controls;
using Thmd.Repeats;

using LibVLCSharp.Shared;
using System.Windows.Media.Imaging;

namespace Thmd.Media;

public interface IPlayer
{
	PlaylistView Playlist { get; }
	Visibility PlaylistVisibility { get; set; }
	ControlBar ControlBar { get; }
    TimeSpan Position { get; set; }
	VLCState State { get; set; }
	bool isPlaying { get; set; }
	bool isPaused { get; set; }
	bool isStoped { get; set; }
	Visibility SubtitleVisibility { get; set; }
	double Volume { get; set; }
	bool isMute { get; set; }
	bool Fullscreen { get; set; }
	void Play();
	void Play(VideoItem media);
	void Pause();
	void Stop();
	void Next();
	void Preview();
	void Seek(TimeSpan time);
	void SetSubtitle(string path);
	void SavePlaylistConfig();
    void LoadPlaylistConfig();
	BitmapSource GetCurrentFrame();
    void Dispose();
	event PropertyChangedEventHandler PropertyChanged;
    event EventHandler<EventArgs> Playing;
    event EventHandler<EventArgs> Stopped;
    event EventHandler<EventArgs> LengthChanged;
    event EventHandler<MediaPlayerTimeChangedEventArgs> TimeChanged;
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\MediaEditor.cs

// Version: 0.1.16.93
using System;
using System.IO;
using System.Windows.Controls;
using System.Windows.Media.Imaging;
using MediaToolkit;
using MediaToolkit.Model;
using MediaToolkit.Options;
using Thmd.Logs;

namespace Thmd.Media;

public class MediaEditor
{
	private Uri _videoUri;

	public MediaEditor(string video_path)
	{
		_videoUri = new Uri(video_path);
	}

	public MediaEditor(Uri video_uri)
	{
		_videoUri = video_uri;
	}

	public Image GetThumbnail()
	{
		MediaFile inputFile = new MediaFile
		{
			Filename = _videoUri.LocalPath ?? ""
		};
		MediaFile outputFile = new MediaFile
		{
			Filename = Path.GetTempFileName()
		};
		using Engine engine = new Engine();
		try
		{
			engine.GetMetadata(inputFile);
			engine.GetThumbnail(inputFile, outputFile, new ConversionOptions
			{
				Seek = TimeSpan.FromSeconds(1.0)
			});
			Image image = new Image();
			image.Source = new BitmapImage(new Uri(outputFile.Filename));
			return image;
		}
		catch (Exception ex)
		{
			Logger.Log.Log(LogLevel.Error, new string[2] { "File", "Console" }, "Error getting thumbnail: " + ex.Message);
			return null;
		}
	}

	public bool CutVideo(string outputPath, TimeSpan startTime, TimeSpan endTime)
	{
		Logger.Log.Log(LogLevel.Info, new string[2] { "File", "Console" }, $"Cutting video from {_videoUri.LocalPath} to {outputPath} from {startTime} to {endTime}");
		MediaFile inputFile = new MediaFile
		{
			Filename = _videoUri.LocalPath ?? ""
		};
		MediaFile outputFile = new MediaFile
		{
			Filename = outputPath ?? ""
		};
		Logger.Log.Log(LogLevel.Info, new string[2] { "File", "Console" }, "Run MediaToolkit engine for cutting.");
		using Engine engine = new Engine();
		try
		{
			engine.GetMetadata(inputFile);
			ConversionOptions options = new ConversionOptions();
			options.CutMedia(startTime, endTime);
			engine.Convert(inputFile, outputFile, options);
			return true;
		}
		catch (Exception ex)
		{
			Logger.Log.Log(LogLevel.Error, new string[2] { "File", "Console" }, "Error cutting video: " + ex.Message);
			return false;
		}
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\Playlist.cs

// Version: 0.1.16.93
using System;
using System.Collections.Generic;

namespace Thmd.Media;

public class Playlist : List<VideoItem>
{
	private VideoItem _current;

	private VideoItem _next;

	private VideoItem _previous;

	private TimeSpan _playlistDuration = TimeSpan.Zero;

	public string Name { get; set; }

	public string Description { get; set; }

	public List<VideoItem> Media { get; private set; }

	public VideoItem Current
	{
		get
		{
			return _current;
		}
		private set
		{
			_current = value;
		}
	}

	public VideoItem Next
	{
		get
		{
			return _next;
		}
		private set
		{
			_next = value;
		}
	}

	public VideoItem Previous
	{
		get
		{
			return _previous;
		}
		private set
		{
			_previous = value;
		}
	}

	public int CurrentIndex => Media.IndexOf(Current);

	public int NextIndex
	{
		get
		{
			int index = Media.IndexOf(Current) + 1;
			if (index >= Media.Count)
			{
				return 0;
			}
			return index;
		}
	}

	public int PreviousIndex
	{
		get
		{
			int index = Media.IndexOf(Current) - 1;
			if (index < 0)
			{
				return Media.Count - 1;
			}
			return index;
		}
	}

	public DateTime CreationDate { get; private set; }

	public string Title
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	public TimeSpan Duration => _playlistDuration;

	public Playlist(string name, string description = "")
	{
		Name = name;
		Description = description;
		Media = new List<VideoItem>();
		CreationDate = DateTime.Now;
	}

	public new void Add(VideoItem media)
	{
		if (media != null)
		{
			Media.Add(media);
			Console.WriteLine("Media \"" + media.Name + "\" has been added to the playlist \"" + Name + "\".");
		}
		else
		{
			Console.WriteLine("Cannot add a null media.");
		}
	}

	public void RemoveMedia(VideoItem media)
	{
		if (media != null)
		{
			if (Media.Remove(media))
			{
				Console.WriteLine("Song \"" + media.Name + "\" has been removed from the playlist \"" + Name + "\".");
			}
			else
			{
				Console.WriteLine("Song \"" + media.Name + "\" was not found in the playlist \"" + Name + "\".");
			}
		}
		else
		{
			Console.WriteLine("Cannot remove a null mediia.");
		}
	}

	public void DisplayMedia()
	{
		if (Media.Count == 0)
		{
			Console.WriteLine("Playlist \"" + Name + "\" is empty.");
			return;
		}
		Console.WriteLine("Media in playlist \"" + Name + "\":");
		foreach (VideoItem mediia in Media)
		{
			Console.WriteLine("- (" + mediia.ToString() + ")");
		}
	}

	public int GetMediaCount()
	{
		return Media.Count;
	}

	public TimeSpan GetTotalDuration()
	{
		TimeSpan totalDuration = TimeSpan.Zero;
		foreach (VideoItem media in Media)
		{
			totalDuration += media.Duration;
		}
		return totalDuration;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\SeekDirection.cs

// Version: 0.1.16.93
namespace Thmd.Media;

/// <summary>
/// Seek video direction
/// </summary>
public enum SeekDirection
{
	/// <summary>
	/// Backward direction
	/// </summary>
	Backward = -1,
    /// <summary>
    /// Forward direction
    /// </summary>
    Forward = 1
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Media\VideoItem.cs

// Version: 0.1.16.80
using System;
using System.ComponentModel;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

using MediaToolkit;
using MediaToolkit.Model;

using Thmd.Consolas;
using Thmd.Controls;
using Thmd.Logs;
using System.Windows.Forms;

namespace Thmd.Media;

[Serializable]
public class VideoItem : UIElement, INotifyPropertyChanged
{
    private int _index = 0;
    private Uri _uri;
    private string _name;
    private double _position = 0.0;
    private double _volume = 1.0;
    private double _duration;
    private IPlayer _player;
    private double _fps;
    private Metadata _metadataMediaToolkit;
    private string _format;
    private string _frameSize;
    private string _audioFormat;
    private string _audioSampleRate;
    private int _audioBitRate;
    private string _audioChanelOutput;

    /// <summary>
    /// MediaType property representing the type of media (e.g., video, audio, etc.).
    /// </summary>
    public object MediaType { get; private set; }

    public int Id { get => _index; }
    /// <summary>
    /// BaseString property representing the media name.
    /// </summary>
    public string Name
    {
        get
        {
            return _name;
        }
        set
        {
            _name = value;
            OnPropertyChanged("BaseString");
        }
    }
    /// <summary>
    /// URI property representing the media file path.
    /// </summary>
    public Uri Uri => _uri;
    /// <summary>
    /// Duration property in TimeSpan format.
    /// </summary>
    public TimeSpan Duration
    {
        get
        {
            string stringTime = TimeSpan.FromMilliseconds(_duration).ToString("hh\\:mm\\:ss");
            return TimeSpan.Parse(stringTime);
        }
    }
    /// <summary>
    /// Player instance associated with this media item.
    /// </summary>
    public IPlayer Player => _player;
    /// <summary>
    /// Frames per second (FPS) of the video, e.g., 24.0, 30.0, 60.0, etc.
    /// </summary>
    public double Fps => GetFPS();
    /// <summary>
    /// Video format, e.g., "mp4", "mkv", "avi", etc.
    /// </summary>
    public string Format => GetFormat();
    /// <summary>
    /// Frame size, e.g., "1920x1080", "1280x720", etc.
    /// </summary>
    public string FrameSize => GetFrameSize();
    /// <summary>
    /// Audio format, e.g., "mp3", "aac", "ac3", etc.
    /// </summary>
    public string AudioFormat => GetAudioFormat();
    /// <summary>
    /// Audio sample rate in Hz, e.g., "44100 Hz", "48000 Hz", etc.
    /// </summary>
    public string AudioSampleRate => GetAudioSampleRate();
    /// <summary>
    /// Audio bit rate in kbps, e.g., 128, 256, etc.
    /// </summary>
    public int AudioBitRate => GetAudioBitRate();
    /// <summary>
    /// Audio channel output, e.g., "stereo", "5.1", etc.
    /// </summary>
    public string AudioChanelOutput => GetAudioChanelOutput();
    /// <summary>
    /// Media stream information, if no media stream is found, it will be null.
    /// </summary>
    public IMediaStream MediaStream { get; private set; }
    /// <summary>
    /// Subtitle file path, if no subtitle is found, it will be an empty string.
    /// </summary>
    public string SubtitlePath { get; set; }
    /// <summary>
    /// Position property in milliseconds, range from 0.0 to Duration.
    /// </summary>
    public double Position
    {
        get
        {
            return _position;
        }
        set
        {
            if (value >= 0.0 && value <= _duration)
            {
                _position = value;
                OnPositionChanged(value);
                OnPropertyChanged("Position");
                OnPropertyChanged("PositionFormatted");
            }
        }
    }

    /// <summary>
    /// Get the formatted position as a string in "hh:mm:ss" format.
    /// </summary>
    public string PositionFormatted => TimeSpan.FromMilliseconds(_position).ToString("hh\\:mm\\:ss");
    /// <summary>
    /// Volume property, range from 0.0 (mute) to 1.0 (max volume).
    /// </summary>
    public double Volume
    {
        get
        {
            return _volume;
        }
        set
        {
            if (value >= 0.0 && value <= 1.0)
            {
                _volume = value;
                OnVolumeChanged(value);
                OnPropertyChanged("Volume");
            }
        }
    }

    /// <summary>
    /// Invoke when a property is changed.
    /// </summary>
    public event PropertyChangedEventHandler PropertyChanged;

    /// <summary>
    /// Invoke when the position is changed.
    /// </summary>
    public event EventHandler<double> PositionChanged;

    /// <summary>
    /// Invoke when the volume is changed.
    /// </summary>
    public event EventHandler<double> VolumeChanged;

    /// <summary>
    /// Invoke when the player instance is changed.
    /// </summary>
    public event EventHandler<IPlayer> PlayerChanged;

    /// <summary>
    /// Invoke when a property is changed.
    /// </summary>
    /// <param name="propertyName">property name in string</param>
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    /// <summary>
    /// Invoke when the position is changed.
    /// </summary>
    /// <param name="newPosition">New position</param>
    protected virtual void OnPositionChanged(double newPosition)
    {
        this.WriteLine($"Position change event: {newPosition}");
        PositionChanged?.Invoke(this, newPosition);
    }

    /// <summary>
    /// Invoke when the volume is changed.
    /// </summary>
    /// <param name="newVolume">double volume value</param>
    protected virtual void OnVolumeChanged(double newVolume)
    {
        this.WriteLine($"Volume change: {newVolume}");
        VolumeChanged?.Invoke(this, newVolume);
    }

    /// <summary>
    /// Invoke when the player instance is changed.
    /// </summary>
    /// <param name="player">IPlayer interface</param>
    protected virtual void OnPlayerChanged(IPlayer player)
    {
        this.WriteLine($"Player change event: {player}");
        PlayerChanged?.Invoke(this, player);
    }

    /// <summary>
    /// Initialize a new instance of the VideoItem class with a specified file path.
    /// </summary>
    /// <param name="path">Media path</param>
    public VideoItem(string path)
    {
        _index++;
        _uri = new Uri(path);
        _name = new FileInfo(_uri.LocalPath).Name;
        _metadataMediaToolkit = GetMetadata();
        if (_metadataMediaToolkit != null)
        {
            _fps = GetFPS();
            _duration = GetDuration();
            _format = GetFormat();
            _frameSize = GetFrameSize();
            _audioFormat = GetAudioFormat();
            _audioSampleRate = GetAudioSampleRate();
            _audioBitRate = GetAudioBitRate();
        }
        else
        {
            _fps = 0.0;
            _duration = 0.0;
            _format = string.Empty;
            _frameSize = string.Empty;
            _audioFormat = string.Empty;
            _audioSampleRate = string.Empty;
            _audioBitRate = 0;
            _audioChanelOutput = string.Empty;
        }
        AutoSetSubtitle(path);
    }

    /// <summary>
    /// Initialize a new instance of the VideoItem class with a specified media player.
    /// </summary>
    /// <param name="path"></param>
    /// <param name="player"></param>
    public VideoItem(string path, IPlayer player)
        : this(path)
    {
        _player = player;
    }

    /// <summary>
    /// Dispose the media item and release resources.
    /// </summary>
    public void Dispose()
    {
        _player.Dispose();
        Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Disposing: " + Name);
    }

    /// <summary>
    /// Set the media player instance for this media item.
    /// </summary>
    /// <param name="player"></param>
    public void SetPlayer(IPlayer player)
    {
        try
        {
            _player = player;
            OnPlayerChanged(player);
        }
        catch (Exception ex)
        {
            this.WriteLine($"Error with player set in media class. In media: {Uri}. {ex.Message}");
        }
    }

    private void AutoSetSubtitle(string path)
    {
        FileInfo file = new FileInfo(path);
        var tmp = ReturnNameWithoutExtension(file);
        var subtitle = String.Empty;

        if (File.Exists($"{tmp}.{Subtitles.SubtitleExtensions.txt}"))
        {
            SubtitlePath = $"{tmp}.{Subtitles.SubtitleExtensions.txt}";
            this.WriteLine($"Auto set subtitle {SubtitlePath}");
        }
        else if (File.Exists($"{tmp}.{Subtitles.SubtitleExtensions.sub}"))
        {
            SubtitlePath = $"{tmp}.{Subtitles.SubtitleExtensions.sub}";
            this.WriteLine($"Auto set subtitle {SubtitlePath}");
        }
        else if (File.Exists($"{tmp}.{Subtitles.SubtitleExtensions.srt}"))
        {
            SubtitlePath = $"{tmp}.{Subtitles.SubtitleExtensions.srt}";
            this.WriteLine($"Auto set subtitle {SubtitlePath}");
        }
        else
        {
            SubtitlePath = String.Empty;
            this.WriteLine("No auto subtitle.");
        }
    }

    private string ReturnNameWithoutExtension(FileInfo item)
    {
        return item.FullName.Remove(item.FullName.Length - item.Extension.Length, item.Extension.Length);
    }

    /// <summary>
    /// Start or resume media playback.
    /// </summary>
    public void Play()
    {
        _player.Play(this);
        this.WriteLine($"[{GetType().Name}]: Playing media {Name}");
    }

    /// <summary>
    /// Pause the media playback.
    /// </summary>
    public void Pause()
    {
        _player.Pause();
        this.WriteLine($"[{GetType().Name}]Pause media {Name}");
    }

    /// <summary>
    /// Stop the media playback and reset the position to the beginning.
    /// </summary>
    public void Stop()
    {
        _player.Stop();
        Position = 0.0;
        this.WriteLine($"[{GetType().Name}]Stopped media {Name}");
    }

    /// <summary>
    /// Move the media position forward by a specified number of seconds.
    /// </summary>
    /// <param name="seconds">In seconds</param>
    public void Forward(double seconds)
    {
        Position += seconds;
        Logger.Log.Log(LogLevel.Info, new string[] { "Console", "File" }, $"[{GetType().Name}]: Change position to forward with +{seconds} second(s)");
    }

    /// <summary>
    /// Rewind the media position by a specified number of seconds.
    /// </summary>
    /// <param name="seconds">in seconds</param>
    public void Rewind(double seconds)
    {
        Position -= seconds;
        Logger.Log.Log(LogLevel.Info, new string[] { "Console", "File" }, $"[{GetType().Name}]: Rewind position by -{seconds} second(s)");
    }

    private Metadata GetMetadata()
    {
        if (_uri == null || string.IsNullOrEmpty(_uri.LocalPath) || !File.Exists(_uri.LocalPath))
        {
            Logger.Log.Log(LogLevel.Error, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Invalid media file path: " + _uri?.LocalPath);
            return null;
        }
        try
        {
            MediaFile inputFile = new MediaFile
            {
                Filename = _uri.LocalPath
            };
            using (Engine engine = new Engine())
            {
                engine.GetMetadata(inputFile);
            }
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Get metadata for media: " + _uri.LocalPath);
            return inputFile.Metadata;
        }
        catch (Exception exception)
        {
            Logger.Log.Log(LogLevel.Error, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Error getting metadata for media: " + _uri.LocalPath, exception);
            return null;
        }
    }

    private double GetDuration()
    {
        try
        {
            double duration = _metadataMediaToolkit.Duration.TotalMilliseconds;
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: Get media {TimeSpan.FromMilliseconds(duration)} duration");
            return duration;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return 0;
        }
    }

    private double GetFPS()
    {
        try
        {
            if (_metadataMediaToolkit != null)
            {
                double fps = _metadataMediaToolkit.VideoData.Fps;
                Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: Get media {fps} frame_size");
                return fps;
            }
            return 0;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return 0;
        }
    }

    private string GetFormat()
    {
        try
        {
            if (_metadataMediaToolkit != null)
            {
                string format = _metadataMediaToolkit.VideoData.Format;
                Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Get media " + format + " format");
                return format;
            }
            return String.Empty;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return String.Empty;
        }
    }

    private string GetFrameSize()
    {
        try
        {
            if (_metadataMediaToolkit != null)
            {
                string frame_size = _metadataMediaToolkit.VideoData.FrameSize;
                Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Get media " + frame_size + " frame_size");
                return frame_size;
            }
            return String.Empty;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return String.Empty;
        }
    }

    private string GetAudioFormat()
    {
        try
        {
            if (_metadataMediaToolkit != null)
            {
                string format = _metadataMediaToolkit.AudioData.Format;
                Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Get media " + format + " audio_format");
                return format;
            }
            return String.Empty;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return String.Empty;
        }
    }

    private string GetAudioSampleRate()
    {
        try
        {
            if (_metadataMediaToolkit != null)
            {
                string rate = _metadataMediaToolkit.AudioData.SampleRate;
                Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Get media " + rate + " audio_sample_rate");
                return rate;
            }
            return String.Empty;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return String.Empty;
        }
    }

    private int GetAudioBitRate()
    {
        try
        {
            if (_metadataMediaToolkit != null)
            {
                int rate = _metadataMediaToolkit.AudioData.BitRateKbs;
                Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: Get media {rate} audio_bit_rate");
                return rate;
            }
            return 0;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return 0;
        }
    }

    private string GetAudioChanelOutput()
    {
        try
        {
            if (_metadataMediaToolkit != null)
            {
                string chanel_output = _metadataMediaToolkit.AudioData.ChannelOutput;
                Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, "[" + GetType().Name + "]: Get media " + chanel_output + " audio_channel_output");
                return chanel_output;
            }
            return String.Empty;
        }
        catch (Exception ex)
        {
            Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"[{GetType().Name}]: {ex.Message}");
            return String.Empty;
        }
    }
    /// <summary>
    /// Override ToString method to provide a string representation of the VideoItem.
    /// </summary>
    /// <returns>string</returns>
    public override string ToString()
    {
        return $"BaseString: {Name}, Duration: {Duration}, Format: {Format}";
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Properties\AssemblyInfo.cs

// Version: 0.1.16.93
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Windows.Markup;

[assembly: AssemblyTitle("Thmd")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Thmd")]
[assembly: AssemblyCopyright("Copyright Â©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("983e3d34-cf34-4ea0-a99f-5845276458f2")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: XmlnsDefinition("http://schemas.thmd.com/controls", "Thmd.Controls")]



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Repeats\RepeatType.cs

// Repeat.cs
// Version: 0.1.16.93
namespace Thmd.Repeats;

// Placeholder for Repeat enum (assumed to be in Thmd.Repeats)
// Update this enum in the actual Thmd.Repeats namespace to include Random
/// <summary>
/// Defines the repeat modes for media playback.
/// </summary>
public enum RepeatType
{
    /// <summary>
    /// No repeat; playback stops after the current video.
    /// </summary>
    None,
    /// <summary>
    /// Repeats the current video.
    /// </summary>
    One,
    /// <summary>
    /// Repeats all videos in the playlist in order.
    /// </summary>
    All
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Subtitles\Subtitle.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Subtitles;

public class Subtitle
{
	public int Id { get; }

	public TimeSpan StartTime { get; }

	public TimeSpan EndTime { get; }

	public string[] TextLines { get; }

	public Subtitle(int id, TimeSpan startTime, TimeSpan endTime, string[] text)
	{
		Id = id;
		StartTime = startTime;
		EndTime = endTime;
		TextLines = text;
	}

	public override string ToString()
	{
		return string.Format("[{0}] {1} --> {2}: {3}", Id, StartTime, EndTime, string.Join(" ", TextLines));
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Subtitles\SubtitleExtensions.cs

// Version: 0.1.5.10
namespace Thmd.Subtitles
{
    /// <summary>
    /// Supported subtitle file extensions.
    /// </summary>
    public enum SubtitleExtensions
    {
        /// <summary>
        /// SRT is the most common subtitle format.
        /// </summary>
        srt,
        /// <summary>
        /// TXT is a plain text format, sometimes used for subtitles.
        /// </summary>
        txt,
        /// <summary>
        ///  SUB is a subtitle format used by MicroDVD and other players.
        /// </summary>
        sub
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Subtitles\SubtitleFontArgs.cs

// Version: 0.1.16.93
using System;
using System.Windows;
using System.Windows.Media;

namespace Thmd.Subtitles;

public class SubtitleFontArgs : EventArgs
{
	public FontFamily FontFamily { get; set; } = new FontFamily("Calibri");

	public double FontSize { get; set; } = 24.0;

	public FontWeight FontWeight { get; set; } = FontWeights.Normal;

	public TextDecorationCollection FontDecoration { get; set; } = TextDecorations.Baseline;
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Subtitles\SubtitleLoadException.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Subtitles;

public class SubtitleLoadException : Exception
{
	public SubtitleLoadException()
	{
	}

	public SubtitleLoadException(string message)
		: base(message)
	{
	}

	public SubtitleLoadException(string message, Exception innerException)
		: base(message, innerException)
	{
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Subtitles\SubtitleManager.cs

// Version: 0.1.16.93
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows;

namespace Thmd.Subtitles;

public class SubtitleManager
{
	private string _subtitlesFile = "";

	private List<Subtitle> _subtitles = new List<Subtitle>();

	public List<Subtitle> Subtitles => new List<Subtitle>(_subtitles);

	public int Count => _subtitles.Count;

	public string Path
	{
		get
		{
			return _subtitlesFile;
		}
		set
		{
			if (_subtitlesFile != value)
			{
				try
				{
					LoadSubtitlesFromFile(value);
					_subtitlesFile = value;
				}
				catch (SubtitleLoadException ex)
				{
					MessageBox.Show("Error loading subtitles: " + ex.Message);
				}
				catch (SubtitleParseException ex2)
				{
					MessageBox.Show("Error parsing subtitle content: " + ex2.Message);
				}
				catch (Exception ex3)
				{
					MessageBox.Show("An unexpected error occurred: " + ex3.Message);
				}
			}
		}
	}

	public SubtitleManager(string path)
	{
		try
		{
			LoadSubtitlesFromFile(path);
			_subtitlesFile = path;
		}
		catch (SubtitleLoadException ex)
		{
			MessageBox.Show("Error loading subtitles on initialization: " + ex.Message);
		}
		catch (SubtitleParseException ex2)
		{
			MessageBox.Show("Error parsing subtitle content on initialization: " + ex2.Message);
		}
		catch (Exception ex3)
		{
			MessageBox.Show("An unexpected error occurred on initialization: " + ex3.Message);
		}
	}

	public List<Subtitle> GetSubtitles()
	{
		return new List<Subtitle>(_subtitles);
	}

	public List<Subtitle> GetStartToEndTimeSpan(TimeSpan start, TimeSpan end)
	{
		return _subtitles.Where((item) => item.StartTime >= start && item.EndTime <= end).ToList();
	}

	private string ReadFileContent(string path)
	{
		FileInfo file = new FileInfo(path);
		if (!file.Exists)
		{
			throw new FileNotFoundException("SetSubtitle file not found.", path);
		}
		try
		{
			return File.ReadAllText(file.FullName, Encoding.UTF8);
		}
		catch (Exception innerException)
		{
			throw new IOException("Could not read subtitle file '" + path + "'.", innerException);
		}
	}

	private void LoadSubtitlesFromFile(string path)
	{
		_subtitles.Clear();
		string fileContent;
		try
		{
			fileContent = ReadFileContent(path);
		}
		catch (Exception innerException)
		{
			throw new SubtitleLoadException("Failed to load file '" + path + "'.", innerException);
		}
		Regex regex = new Regex("^(\\d+)\\r?\\n(\\d{2}:\\d{2}:\\d{2},\\d{3})\\s*-->\\s*(\\d{2}:\\d{2}:\\d{2},\\d{3})\\r?\\n((?:.*\\r?\\n)*?)(?=\\r?\\n\\d+|$)", RegexOptions.Multiline);
		MatchCollection matches = regex.Matches(fileContent);
		if (matches.Count == 0 && !string.IsNullOrWhiteSpace(fileContent))
		{
			throw new SubtitleParseException("No subtitle blocks found or file is malformed.");
		}
		foreach (Match match in matches)
		{
			try
			{
				int id = int.Parse(match.Groups[1].Value);
				TimeSpan startTime = TimeSpan.Parse(match.Groups[2].Value.Replace(',', '.'));
				TimeSpan endTime = TimeSpan.Parse(match.Groups[3].Value.Replace(',', '.'));
				string[] text = match.Groups[4].Value.Trim().Split(new string[2] { "\r\n", "\n" }, StringSplitOptions.RemoveEmptyEntries);
				_subtitles.Add(new Subtitle(id, startTime, endTime, text));
			}
			catch (FormatException innerException2)
			{
				throw new SubtitleParseException("Error parsing subtitle block (ID: " + match.Groups[1].Value + "). Check format of times or text. Raw block: \n" + match.Value, innerException2);
			}
			catch (Exception innerException3)
			{
				throw new SubtitleParseException("An unexpected error occurred while processing subtitle block (ID: " + match.Groups[1].Value + ").", innerException3);
			}
		}
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Subtitles\SubtitleParseException.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Subtitles;

public class SubtitleParseException : Exception
{
	public SubtitleParseException()
	{
	}

	public SubtitleParseException(string message)
		: base(message)
	{
	}

	public SubtitleParseException(string message, Exception innerException)
		: base(message, innerException)
	{
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Templates\Buttons.xaml.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Markup;

namespace Thmd.Templates;

public partial class Buttons : ResourceDictionary
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Templates\PlayerMainButtons.xaml.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Markup;

namespace Thmd.Templates;

public partial class PlayerMainButtons : ResourceDictionary
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Templates\PlayerSecondButtons.xaml.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Markup;

namespace Thmd.Templates;

public partial class PlayerSecondButtons : ResourceDictionary
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Templates\ProgressBarTheme.xaml.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Markup;

namespace Thmd.Templates;

public partial class ProgressBarTheme : ResourceDictionary
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Templates\RepeatButton.xaml.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Markup;

namespace Thmd.Templates;

public partial class RepeatButton : ResourceDictionary
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Templates\ScrollViewerStyle.xaml.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Markup;

namespace Thmd.Templates;

public partial class ScrollViewerStyle : ResourceDictionary
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Themes\Generic.xaml.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Markup;

namespace Thmd.Themes;

public partial class Generic : ResourceDictionary
{
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Translator\ILanguage.cs

// Version: 0.1.5.9
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

using Thmd.Consolas;
using Thmd.Controls;

namespace Thmd.Translator
{
    public interface ILanguage
    {
        string Name { get; set; }
        string Code { get; set; }
        List<ITranslation> Translations { get; set; }
    }

    public interface ITranslation
    {
        object Control { get; }
        List<Translate> Translates { get; }
    }

    public class Translate
    {
        public string Key { get; set; }
        public string Value { get; set; }
    }

    public class Translation : ITranslation
    {
        private string _key;
        private string _value;
        private object _control;
        private List<Translate> _translations = new List<Translate>();

        /// <summary>
        /// Control witch can we change
        /// </summary>
        public object Control => _control;
        /// <summary>
        /// Translates list for Control
        /// </summary>
        public List<Translate> Translates => _translations;

        /// <summary>
        /// Class creator
        /// </summary>
        public Translation(object control)
        {
            _control = control;
            _translations = new List<Translate>();
        }
        /// <summary>
        /// Class creator with starting keys and values
        /// </summary>
        /// <param name="translation_key">string</param>
        /// <param name="translation_value">string</param>
        public Translation(object control, string translation_key, string translation_value)
        {
            _key = translation_key;
            _value = translation_value;
            _control = control;
            _translations.Add(new Translate { Key = _key, Value = _value });
        }
        /// <summary>
        /// Add translate
        /// </summary>
        /// <param name="translate">table of translate</param>
        public void AddTranslate(Translate[] translate)
        {
            try
            {
                _translations.AddRange(translate);
            }
            catch (Exception ex)
            {
                this.WriteLine(ex.ToString());
            }
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Translator\Language.cs

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

using Thmd.Translator;

namespace Thmd.Translator;
    public static class Language
    {
        private static IList<ILanguage> _langs = new List<ILanguage>();
        private static Dictionary<string, string> _translations = new Dictionary<string, string>();

        private static string _path = "Languages/";

        public static string LanguageDir { get => _path; }

        public static IList<ILanguage> LoadLanguage(string dir_path = null)
        {
            if (dir_path != null)
            {
                SetLanguagesDir(dir_path);
            }

            if (!Directory.Exists(_path))
            {
                Directory.CreateDirectory(_path);
            }

            var files = Directory.GetFiles(_path, "*.dll");

            if (files != null)
            {
                foreach (var file in files)
                {
                    var assembly = Assembly.LoadFrom(file);
                    var types = assembly.GetExportedTypes();

                    foreach (Type type in types)
                    {
                        if (type.GetInterfaces().Contains(typeof(ILanguage)))
                        {
                            var obj = Activator.CreateInstance(type);
                            _langs.Add(obj as ILanguage);
                        }
                    }
                }
            }
            return _langs;
        }

        private static void SetLanguagesDir(string dir)
        {
            var dir_path = new DirectoryInfo(dir);
            if (dir_path.Exists)
            {
                _path = dir_path.FullName;
            }
        }

        public static object UseLanguage<T>(this T obj)
        {
            if (_langs.Contains((ILanguage)obj))
                return (T)Activator.CreateInstance(obj.GetType());
            else
                return null;
        }

    /// <summary>
    /// Rekurencyjnie tï¿½umaczy teksty w kontrolkach drzewa wizualnego.
    /// Obsï¿½uguje TextBlock, Button (Translate), Label, MenuItem (Header) itp.
    /// </summary>
    /// <param name="obj">Obiekt DependencyObject do przetworzenia (kontrolka lub kontener).</param>
    public static void TranslateControls(DependencyObject obj)
    {
        if (obj == null) return;

        // Przetwarzaj bieï¿½ï¿½cy obiekt
        TranslateSingleControl(obj);

        // Przetwarzaj dzieci rekurencyjnie
        int childrenCount = VisualTreeHelper.GetChildrenCount(obj);
        for (int i = 0; i < childrenCount; i++)
        {
            DependencyObject child = VisualTreeHelper.GetChild(obj, i);
            TranslateControls(child);
        }
    }

    /// <summary>
    /// Tï¿½umaczy tekst w pojedynczej kontrolce na podstawie jej typu.
    /// </summary>
    /// <param name="control">Kontrolka do przetï¿½umaczenia.</param>
    public static void TranslateSingleControl(DependencyObject control)
    {
        switch (control)
        {
            case TextBlock textBlock:
                if (_translations.TryGetValue(textBlock.Text, out string translatedTextBlock))
                {
                    textBlock.Text = translatedTextBlock;
                }
                break;

            case Button button:
                if (button.Content is string buttonContent && _translations.TryGetValue(buttonContent, out string translatedButton))
                {
                    button.Content = translatedButton;
                }
                break;

            case Label label:
                if (label.Content is string labelContent && _translations.TryGetValue(labelContent, out string translatedLabel))
                {
                    label.Content = translatedLabel;
                }
                break;

            case MenuItem menuItem:
                if (menuItem.Header is string menuHeader && _translations.TryGetValue(menuHeader, out string translatedMenu))
                {
                    menuItem.Header = translatedMenu;
                }
                break;

            //Dodaj obsï¿½ugï¿½ innych typï¿½w kontrolek, np. CheckBox, ToolTip itp., jeï¿½li potrzeba
            case CheckBox checkBox:
                 if (checkBox.Content is string cbContent && _translations.TryGetValue(cbContent, out string translatedCb))
                 {
                     checkBox.Content = translatedCb;
                 }
                 break;

            default:
                // Ignoruj inne typy
                break;
        }
    }
}
// Version: 0.1.5.10



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Translator\LanguageChanger.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Controls;

namespace Thmd.Translator
{
    public static class LanguageChanger
    {
        public static ILanguage Translation { get; private set; }
        public static IList<ILanguage> Languages { get; private set; } = new List<ILanguage>();

        /// <summary>
        /// Change or refresh language
        /// </summary>
        public static void ChangeLanguage()
        {
            Translation = Translation.UseLanguage() as ILanguage;
        }

        public static void ChangeLanguage(string language)
        {
            if (language == String.Empty)
            {
                Console.WriteLine("Don't know language: 'empty string'");
                return;
            }
            foreach (var item in Languages)
            {
                if (item.Name == language)
                    Translation = item.UseLanguage() as ILanguage;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="language"></param>
        public static void ChangeLanguage(this object obj, string language = null)
        {
            var control = obj as Control;

            if (language == null || language == String.Empty)
            {
                Console.WriteLine($"Can't change language. I don't know: '{language}' language.");
                Console.WriteLine($"Trying refresh control: {obj.GetType().Name}");
            }
            else
                ChangeLanguage(language);

            try
            {
                control.InvalidateVisual();
                Console.WriteLine($"Control refreshed.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error with refreshing control: {ex.Message}");
            }
        }
    }
}
// Version: 0.1.0.6



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Updates\ProgressChangedEventArgs.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Updates;

public class ProgressChangedEventArgs : EventArgs
{
	public long BytesReceived { get; }

	public long TotalBytes { get; }

	public int ProgressPercentage => (int)(BytesReceived * 100 / (TotalBytes > 0 ? TotalBytes : 1));

	public ProgressChangedEventArgs(long bytesReceived, long totalBytes)
	{
		BytesReceived = bytesReceived;
		TotalBytes = totalBytes;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Updates\Updat.cs

// Updater.cs
// Version: 0.1.17.82
using System;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Net.Http;
using System.Reflection;
using System.Threading.Tasks;

using SharpCompress.Archives;
using SharpCompress.Common;

using Thmd.Configuration;
using Thmd.Logs;

namespace Thmd.Updates;

/// <summary>
/// A class responsible for checking, downloading, and applying application updates.
/// Uses configuration settings from the Config class and supports asynchronous operations
/// with progress reporting and error handling.
/// </summary>
public class Updat : IDisposable
{
    private readonly HttpClient _httpClient;
    private readonly AsyncLogger _logger;
    private bool _disposed = false;
    private readonly Config _config;

    /// <summary>
    /// Gets the current version of the application.
    /// </summary>
    public Version CurrentVersion { get; private set; }

    /// <summary>
    /// Gets the latest version available from the update manifest.
    /// </summary>
    public Version LatestVersion { get; private set; }

    /// <summary>
    /// Gets the URL to fetch the update manifest from.
    /// </summary>
    public string UpdateManifestUrl => _config.UpdateConfig.VersionUrl;

    /// <summary>
    /// Gets the path to the temporary file where the update package is downloaded.
    /// </summary>
    public string TempFilePath { get; private set; }

    /// <summary>
    /// Occurs when a new update is available.
    /// </summary>
    public event EventHandler<UpdateAvailableEventArgs> UpdateAvailable;

    /// <summary>
    /// Occurs when there is progress in downloading the update.
    /// </summary>
    public event EventHandler<ProgressChangedEventArgs> ProgressChanged;

    /// <summary>
    /// Occurs when the update process is completed successfully.
    /// </summary>
    public event EventHandler UpdateCompleted;

    /// <summary>
    /// Occurs when an error happens during the update process.
    /// </summary>
    public event EventHandler<UpdateErrorEventArgs> UpdateFailed;

    /// <summary>
    /// Initializes a new instance of the <see cref="Updat"/> class using settings from the <see cref="Config"/> class.
    /// </summary>
    public Updat()
    {
        _httpClient = new HttpClient
        {
            Timeout = TimeSpan.FromSeconds(Config.Instance.UpdateConfig.UpdateTimeout)
        };
        _logger = new AsyncLogger();
        _config = Config.Instance;
        CurrentVersion = Assembly.GetExecutingAssembly().GetName().Version ?? new Version(0, 1, 0, 99);
    }

    /// <summary>
    /// Disposes the resources used by the <see cref="Updat"/>.
    /// </summary>
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Disposes the resources used by the <see cref="Updat"/>.
    /// </summary>
    /// <param name="disposing">True to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
        {
            return;
        }
        if (disposing)
        {
            _httpClient?.Dispose();
            _logger?.Dispose();
        }
        _disposed = true;
    }

    /// <summary>
    /// Checks for updates by fetching the latest version from the update manifest URL.
    /// </summary>
    /// <returns>True if an update is available; otherwise, false.</returns>
    public async Task<bool> CheckForUpdatesAsync()
    {
        if (!_config.UpdateConfig.CheckForUpdates)
        {
            _logger.Log(LogLevel.Info, new[] { "Console", "File" }, "Update checking is disabled in configuration.");
            return false;
        }

        try
        {
            string manifestContent = await _httpClient.GetStringAsync(UpdateManifestUrl);
            LatestVersion = ParseVersionFromManifest(manifestContent);
            if (LatestVersion > CurrentVersion)
            {
                UpdateAvailable?.Invoke(this, new UpdateAvailableEventArgs(LatestVersion));
                _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"New version available: {LatestVersion}");
                return true;
            }
            _logger.Log(LogLevel.Info, new[] { "Console", "File" }, "No new updates available.");
            return false;
        }
        catch (Exception ex)
        {
            UpdateFailed?.Invoke(this, new UpdateErrorEventArgs(ex));
            _logger.Log(LogLevel.Error, new[] { "Console", "File" }, $"Error checking for updates: {ex.Message}", ex);
            return false;
        }
    }

    /// <summary>
    /// Downloads the update package from the configured URL and saves it to a temporary file.
    /// </summary>
    /// <returns>A task representing the asynchronous download operation.</returns>
    public async Task DownloadUpdateAsync()
    {
        try
        {
            string updateDir = Path.GetFullPath(_config.UpdateConfig.UpdatePath);
            if (!Directory.Exists(updateDir))
            {
                Directory.CreateDirectory(updateDir);
                _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"Directory created: {updateDir}");
            }

            TempFilePath = Path.Combine(updateDir, _config.UpdateConfig.UpdateFileName);
            using HttpResponseMessage response = await _httpClient.GetAsync(_config.UpdateConfig.UpdateUrl, HttpCompletionOption.ResponseHeadersRead);
            response.EnsureSuccessStatusCode();

            using Stream streamToRead = await response.Content.ReadAsStreamAsync();
            using FileStream streamToWrite = File.OpenWrite(TempFilePath);
            long totalBytes = response.Content.Headers.ContentLength ?? -1;
            byte[] buffer = new byte[8192];
            long totalBytesRead = 0;

            while (true)
            {
                int bytesRead = await streamToRead.ReadAsync(buffer, 0, buffer.Length);
                if (bytesRead <= 0)
                {
                    break;
                }
                await streamToWrite.WriteAsync(buffer, 0, bytesRead);
                totalBytesRead += bytesRead;
                ProgressChanged?.Invoke(this, new ProgressChangedEventArgs(totalBytesRead, totalBytes));
            }

            UpdateCompleted?.Invoke(this, EventArgs.Empty);
            _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"Update downloaded to: {TempFilePath}");
        }
        catch (Exception ex)
        {
            UpdateFailed?.Invoke(this, new UpdateErrorEventArgs(ex));
            _logger.Log(LogLevel.Error, new[] { "Console", "File" }, $"Error downloading update: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Applies the downloaded update by extracting the archive (RAR or ZIP) and replacing files in the current application directory, then exiting the application.
    /// </summary>
    public void ApplyUpdate()
    {
        if (string.IsNullOrEmpty(TempFilePath) || !File.Exists(TempFilePath))
        {
            var ex = new FileNotFoundException($"Update package not found at: {TempFilePath}");
            UpdateFailed?.Invoke(this, new UpdateErrorEventArgs(ex));
            _logger.Log(LogLevel.Error, new[] { "Console", "File" }, ex.Message, ex);
            return;
        }

        try
        {
            string updateDir = Path.GetFullPath(_config.UpdateConfig.UpdatePath);
            string extractDir = Path.Combine(updateDir, "extracted");
            string appDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
                ?? throw new InvalidOperationException("Unable to determine application directory.");
            string extension = Path.GetExtension(TempFilePath)?.ToLowerInvariant();

            // Create extraction directory
            if (!Directory.Exists(extractDir))
            {
                Directory.CreateDirectory(extractDir);
                _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"Extraction directory created: {extractDir}");
            }

            // Extract the archive based on its type
            if (extension == ".zip")
            {
                ZipFile.ExtractToDirectory(TempFilePath, extractDir, System.Text.Encoding.UTF8);
                _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"Extracted ZIP archive to: {extractDir}");
            }
            else if (extension == ".rar")
            {
                using var archive = ArchiveFactory.Open(TempFilePath);
                foreach (var entry in archive.Entries)
                {
                    if (!entry.IsDirectory)
                    {
                        entry.WriteToDirectory(extractDir, new ExtractionOptions
                        {
                            Overwrite = true,
                            ExtractFullPath = true
                        });
                    }
                }
                _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"Extracted RAR archive to: {extractDir}");
            }
            else
            {
                var ex = new NotSupportedException($"Unsupported archive format: {extension}");
                UpdateFailed?.Invoke(this, new UpdateErrorEventArgs(ex));
                _logger.Log(LogLevel.Error, new[] { "Console", "File" }, ex.Message, ex);
                return;
            }

            // Copy extracted files to the application directory, overwriting existing files
            CopyDirectory(extractDir, appDir);
            _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"Copied extracted files to: {appDir}");

            // Clean up: Delete extracted directory and original archive
            try
            {
                Directory.Delete(extractDir, recursive: true);
                File.Delete(TempFilePath);
                _logger.Log(LogLevel.Info, new[] { "Console", "File" }, $"Cleaned up: {extractDir} and {TempFilePath}");
            }
            catch (Exception cleanupEx)
            {
                _logger.Log(LogLevel.Warning, new[] { "Console", "File" },
                    $"Failed to clean up extracted files: {cleanupEx.Message}", cleanupEx);
            }

            _logger.Log(LogLevel.Info, new[] { "Console", "File" }, "Update applied successfully. Exiting application.");
            ScheduleFileReplacement(extractDir, appDir);
            Environment.Exit(0);
        }
        catch (Exception ex)
        {
            UpdateFailed?.Invoke(this, new UpdateErrorEventArgs(ex));
            _logger.Log(LogLevel.Error, new[] { "Console", "File" }, $"Error applying update: {ex.Message}", ex);
        }
    }

    private void ScheduleFileReplacement(string sourceDir, string destDir)
    {
        string batchFile = Path.Combine(_config.UpdateConfig.UpdatePath, "update.bat");
        string script = $"@echo off\n" +
                        $"timeout /t 2\n" +
                        $"xcopy \"{sourceDir}\" \"{destDir}\" /E /H /C /I /Y\n" +
                        $"del \"{batchFile}\"\n";
        File.WriteAllText(batchFile, script);
        Process.Start(new ProcessStartInfo
        {
            FileName = batchFile,
            UseShellExecute = true,
            Verb = "runas"
        });
    }

    /// <summary>
    /// Recursively copies all files and directories from the source directory to the destination directory, overwriting existing files.
    /// </summary>
    /// <param name="sourceDir">The source directory to copy from.</param>
    /// <param name="destDir">The destination directory to copy to.</param>
    private void CopyDirectory(string sourceDir, string destDir)
    {
        try
        {
            DirectoryInfo dir = new DirectoryInfo(sourceDir);
            DirectoryInfo[] subDirs = dir.GetDirectories();
            FileInfo[] files = dir.GetFiles();

            if (!Directory.Exists(destDir))
            {
                Directory.CreateDirectory(destDir);
            }

            foreach (FileInfo file in files)
            {
                string destFilePath = Path.Combine(destDir, file.Name);
                try
                {
                    file.CopyTo(destFilePath, overwrite: true);
                    _logger.Log(LogLevel.Info, new[] { "Console", "File" },
                        $"Copied file: {destFilePath}");
                }
                catch (IOException ioEx)
                {
                    _logger.Log(LogLevel.Warning, new[] { "Console", "File" },
                        $"Failed to copy file {file.FullName}: {ioEx.Message}", ioEx);
                    // Continue copying other files
                }
            }

            foreach (DirectoryInfo subDir in subDirs)
            {
                string destSubDir = Path.Combine(destDir, subDir.Name);
                CopyDirectory(subDir.FullName, destSubDir);
            }
        }
        catch (Exception ex)
        {
            throw new IOException($"Failed to copy directory {sourceDir} to {destDir}: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Parses the version string from the manifest content.
    /// </summary>
    /// <param name="manifestContent">The content of the update manifest.</param>
    /// <returns>The parsed version.</returns>
    /// <exception cref="ArgumentException">Thrown if the manifest content is not a valid version string.</exception>
    private Version ParseVersionFromManifest(string manifestContent)
    {
        if (string.IsNullOrWhiteSpace(manifestContent) || !Version.TryParse(manifestContent.Trim(), out var version))
        {
            throw new ArgumentException("Invalid version format in manifest content.");
        }
        return version;
    }
}

/// <summary>
/// Event arguments for the UpdateFailed event.
/// </summary>
public class UpdateErrorEventArgs : EventArgs
{
    /// <summary>
    /// Gets the exception that occurred during the update process.
    /// </summary>
    public Exception Exception { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="UpdateErrorEventArgs"/> class with the specified exception.
    /// </summary>
    /// <param name="exception">The exception that occurred.</param>
    /// <exception cref="ArgumentNullException">Thrown if the exception is null.</exception>
    public UpdateErrorEventArgs(Exception exception)
    {
        Exception = exception ?? throw new ArgumentNullException(nameof(exception));
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Updates\UpdateAvailableEventArgs.cs

// Version: 0.1.16.93
using System;

namespace Thmd.Updates;

public class UpdateAvailableEventArgs : EventArgs
{
	public Version NewVersion { get; }

	public UpdateAvailableEventArgs(Version newVersion)
	{
		NewVersion = newVersion;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\CommandLineHandler.cs

// CommandLineHandler.cs
// Version: 0.1.11.57
using System;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Windows;

using Thmd.Logs; // Dla logowania, jeÅ›li dostÄ™pne

namespace Thmd.Utilities
{
    public static class CommandLineHandler
    {
        public static double? InitialVolume { get; set; } = 100;
        public static string PlaylistToLoadOnStartup { get; set; } = "playlist.json";
        public static bool StartInFullscreen { get; set; } = false;
        public static string MediaFileToOpenOnStartup { get; set; } = "mediafile.mp4";

        private static readonly (string Flag, string Description)[] AvailableFlags = {
            ("-h", "Display this help message and exit."),
            ("--help", "Display this help message and exit."),
            ("-f <file>", "Open and play the specified media file (e.g., thmdplayer.exe -f \"C:\\video.mp4\")."),
            ("--debug", "run program and run performance monitor for applikation"),
            ("--fullscreen", "Start the player in fullscreen mode."),
            ("--playlist <file>", "Load the specified playlist file (e.g., thmdplayer.exe --playlist \"C:\\playlist.m3u\")."),
            ("--volume <level>", "Set initial volume level (0-100, e.g., thmdplayer.exe --volume 50).")
        };

        public static bool ProcessArguments(string[] args)
        {
            if (args == null || args.Length == 0)
            {
                return true;
            }

            bool isHelpRequested = args.Any(arg => arg.Equals("-h", StringComparison.OrdinalIgnoreCase) ||
                                                   arg.Equals("--help", StringComparison.OrdinalIgnoreCase));

            if (isHelpRequested)
            {
                ShowHelp();
                Application.Current?.Shutdown(0);
                return false;
            }

            for (int i = 0; i < args.Length; i++)
            {
                string arg = args[i].ToLowerInvariant();

                switch (arg)
                {
                    case "-f":
                    case "--file":
                        if (i + 1 < args.Length)
                        {
                            string filePath = args[++i];
                            if (!string.IsNullOrEmpty(filePath) && System.IO.File.Exists(filePath))
                            {
                                MediaFileToOpenOnStartup = filePath; // Zaktualizowana przestrzeÅ„ nazw
                                Logger.Log.Log(LogLevel.Info, new[] { "Console", "File" }, $"Will open file: {filePath}");
                            }
                            else
                            {
                                ShowError("Invalid or non-existent file path provided.");
                            }
                        }
                        else
                        {
                            ShowError("File path expected after -f or --file flag.");
                        }
                        break;
                    case "-d":
                    case "--debug":
                        Console.WriteLine(Process.GetCurrentProcess().ProcessName);
                        Process.Start("PerformanceMonitorApp.exe", "--process " + Process.GetCurrentProcess().ProcessName);
                        break;

                    case "--fullscreen":
                        StartInFullscreen = true; // Zaktualizowana przestrzeÅ„ nazw
                        Logger.Log.Log(LogLevel.Info, new[] { "Console", "File" }, "Starting in fullscreen mode.");
                        break;

                    case "--playlist":
                        if (i + 1 < args.Length)
                        {
                            string playlistPath = args[++i];
                            if (!string.IsNullOrEmpty(playlistPath) && System.IO.File.Exists(playlistPath))
                            {
                                PlaylistToLoadOnStartup = playlistPath; // Zaktualizowana przestrzeÅ„ nazw
                                Logger.Log.Log(LogLevel.Info, new[] { "Console", "File" }, $"Will load playlist: {playlistPath}");
                            }
                            else
                            {
                                ShowError("Invalid or non-existent playlist path provided.");
                            }
                        }
                        else
                        {
                            ShowError("Playlist path expected after --playlist flag.");
                        }
                        break;

                    case "--volume":
                        if (i + 1 < args.Length)
                        {
                            string volumeStr = args[++i];
                            if (double.TryParse(volumeStr, out double volume) && volume >= 0 && volume <= 100)
                            {
                                InitialVolume = volume; // Zaktualizowana przestrzeÅ„ nazw
                                Logger.Log.Log(LogLevel.Info, new[] { "Console", "File" }, $"Initial volume set to: {volume}");
                            }
                            else
                            {
                                ShowError("Invalid volume level (must be 0-100).");
                            }
                        }
                        else
                        {
                            ShowError("Volume level expected after --volume flag.");
                        }
                        break;

                    default:
                        if (arg.StartsWith("-") || arg.StartsWith("--"))
                        {
                            ShowError($"Unknown flag: {args[i]}");
                        }
                        break;
                }
            }

            return true;
        }

        private static void ShowHelp()
        {
            var assembly = Assembly.GetExecutingAssembly();
            var version = assembly.GetName().Version?.ToString() ?? "Unknown";
            var title = assembly.GetCustomAttribute<AssemblyTitleAttribute>()?.Title ?? "ThmdPlayer";

            Console.WriteLine($@"
{title} v{version} - Command Line Usage
======================================

Usage: thmdplayer.exe [options]

Available options:
");

            foreach (var (flag, description) in AvailableFlags)
            {
                Console.WriteLine($"  {flag,-20} {description}");
            }

            Console.WriteLine(@"
Examples:
  thmdplayer.exe -h                    (Show this help)
  thmdplayer.exe -f ""C:\Videos\movie.mp4""  (Open and play a specific file)
  thmdplayer.exe --fullscreen          (Start in fullscreen mode)
  thmdplayer.exe --playlist ""playlist.m3u"" --volume 70  (Load playlist and set volume)

For more details, run the application without arguments.
");
        }

        private static void ShowError(string message)
        {
            Console.WriteLine($"Error: {message}");
            Console.WriteLine("Use -h or --help for usage information.");
            Logger.Log.Log(LogLevel.Error, new[] { "Console", "File" }, message);
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\DragDropHelper.cs

// Version: 0.1.7.51
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace Thmd.Utilities
{
    public static class DragDropHelper
    {
        public static readonly DependencyProperty IsDragOverProperty = DependencyProperty.RegisterAttached(
            "IsDragOver",
            typeof(bool),
            typeof(DragDropHelper),
            new PropertyMetadata(false));

        public static bool GetIsDragOver(DependencyObject obj)
        {
            return (bool)obj.GetValue(IsDragOverProperty);
        }

        public static void SetIsDragOver(DependencyObject obj, bool value)
        {
            obj.SetValue(IsDragOverProperty, value);
        }
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\GeneratorHelper.cs

// Version: 0.1.16.93
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Thmd.Utilities;

public class GeneratorHelper
{
	private readonly string _programName;

	private readonly string _description;

	private readonly List<OptionHelper> _options;

	public GeneratorHelper(string programName, string description, List<OptionHelper> options)
	{
		_programName = programName;
		_description = description;
		_options = options;
	}

	public void CheckHelp(string[] args)
	{
		if (args.Any((arg) => arg == "--help" || arg == "--_h" || arg == "-_h"))
		{
			Console.WriteLine(GenerateHelp());
			Environment.Exit(0);
		}
	}

	private string GenerateHelp()
	{
		StringBuilder sb = new StringBuilder();
		sb.AppendLine("UÅ¼ycie: " + _programName + " [OPCJE]");
		sb.AppendLine();
		sb.AppendLine("Opis: " + _description);
		sb.AppendLine();
		sb.AppendLine("Opcje:");
		foreach (OptionHelper option in _options)
		{
			string flags = FormatFlags(option);
			sb.AppendLine($"  {flags,-30}  {option.Description}");
		}
		return sb.ToString();
	}

	private string FormatFlags(OptionHelper option)
	{
		string joinedFlags = string.Join(" lub ", option.Flags);
		return option.HasValue ? joinedFlags + " {" + option.ValueType + "}" : joinedFlags;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\OptionHelper.cs

// Version: 0.1.16.93
using System.Collections.Generic;

namespace Thmd.Utilities;

public class OptionHelper
{
	public List<string> Flags { get; }

	public string Description { get; }

	public bool HasValue { get; }

	public string ValueType { get; }

	public OptionHelper(List<string> flags, string description, bool hasValue = false, string valueType = "bool")
	{
		Flags = flags;
		Description = description;
		HasValue = hasValue;
		ValueType = valueType;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\PathCheckHelper.cs

// Version: 0.1.16.93
using System;
using System.Text.RegularExpressions;

namespace Thmd.Utilities;

public class PathCheckHelper
{
	public enum PathEnum
	{
		isNone,
		isFile,
		isUrl
	}

	public static bool IsUrl(string input)
	{
		if (Uri.TryCreate(input, UriKind.Absolute, out var uriResult))
		{
			return uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps || uriResult.Scheme == Uri.UriSchemeFtp || uriResult.Scheme == Uri.UriSchemeFile;
		}
		return false;
	}

	public static bool IsFilePath(string input)
	{
		bool isWindowsPath = Regex.IsMatch(input, "^[a-zA-Z]:\\\\");
		bool isUnixPath = input.StartsWith("/");
		bool isUncPath = input.StartsWith("\\\\");
		bool hasInvalidUrlChars = Regex.IsMatch(input, "\\s|\\[|\\]|\\{|\\}");
		return isWindowsPath || isUnixPath || isUncPath || hasInvalidUrlChars;
	}

	public static PathEnum Check(string input)
	{
		if (IsUrl(input))
		{
			Console.WriteLine("'" + input + "' to URL");
			return PathEnum.isUrl;
		}
		if (IsFilePath(input))
		{
			Console.WriteLine("'" + input + "' to Å›cieÅ¼ka pliku");
			return PathEnum.isFile;
		}
		Console.WriteLine("Nie moÅ¼na okreÅ›liÄ‡ typu: '" + input + "'");
		return PathEnum.isNone;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\ResizeControlHelper.cs

// Version: 0.1.10.4
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

namespace Thmd.Utilities;

public class ResizeControlHelper
{
    private enum ResizeDirection
    {
        None,
        Top,
        Bottom,
        Left,
        Right,
        TopLeft,
        TopRight,
        BottomLeft,
        BottomRight,
        Moving
    }

    private readonly FrameworkElement _element;

    private bool _isResizing;

    private bool _isMoving;

    private Point _lastMousePosition;

    private Rect _originalBounds;

    private readonly double _resizeBorderWidth = 3.0;

    private ResizeDirection _resizeDirection;

    private bool _isMouseCaptured;

    public ResizeControlHelper(FrameworkElement element)
    {
        _element = element ?? throw new ArgumentNullException("element");
        InitializeEvents();
    }

    public Cursor GetCursor()
    {
        return _element.Cursor;
    }

    private void InitializeEvents()
    {
        _element.MouseLeftButtonDown += Element_MouseLeftButtonDown;
        _element.MouseMove += Element_MouseMove;
        _element.MouseLeftButtonUp += Element_MouseLeftButtonUp;
        _element.Cursor = Cursors.Arrow;
    }

    private void Element_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        Point position = e.GetPosition(_element);
        ResizeDirection direction = GetResizeDirection(position);
        if (direction != ResizeDirection.None)
        {
            _lastMousePosition = e.GetPosition(GetParentContainer());
            _originalBounds = new Rect(_element.Margin.Left, _element.Margin.Top, _element.ActualWidth, _element.ActualHeight);
            _resizeDirection = direction;
            _isResizing = direction != ResizeDirection.Moving;
            _isMoving = direction == ResizeDirection.Moving;
            _isMouseCaptured = true;
            _element.CaptureMouse();
            e.Handled = true;
        }
    }

    private void Element_MouseMove(object sender, MouseEventArgs e)
    {
        Point position = e.GetPosition(_element);
        ResizeDirection direction = GetResizeDirection(position);
        if (_isMoving)
        {
            MoveElement(e);
        }
        else if (_isResizing)
        {
            ResizeElement(e);
        }
        else
        {
            UpdateCursor(direction);
        }
    }

    private void ResizeElement(MouseEventArgs e)
    {
        UIElement parent = GetParentContainer();
        if (parent != null)
        {
            Point currentPosition = e.GetPosition(parent);
            double dx = currentPosition.X - _lastMousePosition.X;
            double dy = currentPosition.Y - _lastMousePosition.Y;
            Thickness newMargin = _element.Margin;
            double newWidth = _element.ActualWidth;
            double newHeight = _element.ActualHeight;
            switch (_resizeDirection)
            {
                case ResizeDirection.Right:
                    newWidth += dx;
                    break;
                case ResizeDirection.Bottom:
                    newHeight += dy;
                    break;
                case ResizeDirection.Left:
                    newMargin.Left += dx;
                    newWidth -= dx;
                    break;
                case ResizeDirection.Top:
                    newMargin.Top += dy;
                    newHeight -= dy;
                    break;
                case ResizeDirection.TopLeft:
                    newMargin.Left += dx;
                    newWidth -= dx;
                    newMargin.Top += dy;
                    newHeight -= dy;
                    break;
                case ResizeDirection.TopRight:
                    newWidth += dx;
                    newMargin.Top += dy;
                    newHeight -= dy;
                    break;
                case ResizeDirection.BottomLeft:
                    newMargin.Left += dx;
                    newWidth -= dx;
                    newHeight += dy;
                    break;
                case ResizeDirection.BottomRight:
                    newWidth += dx;
                    newHeight += dy;
                    break;
            }
            newWidth = Math.Max(newWidth, _element.MinWidth);
            newHeight = Math.Max(newHeight, _element.MinHeight);
            if (newWidth <= _element.MinWidth && (_resizeDirection == ResizeDirection.Left || _resizeDirection == ResizeDirection.TopLeft || _resizeDirection == ResizeDirection.BottomLeft))
            {
                newMargin.Left = _originalBounds.Left + (_originalBounds.Width - newWidth);
            }
            if (newHeight <= _element.MinHeight && (_resizeDirection == ResizeDirection.Top || _resizeDirection == ResizeDirection.TopLeft || _resizeDirection == ResizeDirection.TopRight))
            {
                newMargin.Top = _originalBounds.Top + (_originalBounds.Height - newHeight);
            }
            _element.Margin = newMargin;
            _element.Width = newWidth;
            _element.Height = newHeight;
            _lastMousePosition = currentPosition;
            e.Handled = true;
        }
    }

    private void MoveElement(MouseEventArgs e)
    {
        UIElement parent = GetParentContainer();
        if (parent != null)
        {
            Point currentPosition = e.GetPosition(parent);
            //Size size = parent.GetWindowSize();
            double dx = currentPosition.X - _lastMousePosition.X;
            double dy = currentPosition.Y - _lastMousePosition.Y;
            Thickness newMargin = _element.Margin;            
            newMargin.Left += dx*2;
            newMargin.Top += dy*2;
            /*if (newMargin.Left <= -size.Width / 2)
            {
                newMargin.Left = -size.Width / 2;
            }
            if (newMargin.Top <= -size.Height/2)
            {
                newMargin.Top = -size.Height/2;
            }
            if (newMargin.Left > size.Width/2)
            {
                newMargin.Left = size.Width / 2;
            }
            if (newMargin.Top > size.Height / 2 + _element.ActualHeight)
            {
                newMargin.Left = size.Height /2 - _element.ActualHeight;
            }*/
            _element.Margin = newMargin;
            _lastMousePosition = currentPosition;
            e.Handled = true;
        }
    }

    private void Element_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (_isResizing || _isMoving)
        {
            _isResizing = false;
            _isMoving = false;
            _element.ReleaseMouseCapture();
            _resizeDirection = ResizeDirection.None;
            _isMouseCaptured = false;
            e.Handled = true;
        }
    }

    private ResizeDirection GetResizeDirection(Point point)
    {
        bool left = point.X < _resizeBorderWidth;
        bool right = point.X > _element.ActualWidth - _resizeBorderWidth;
        bool top = point.Y < _resizeBorderWidth;
        bool bottom = point.Y > _element.ActualHeight - _resizeBorderWidth;
        bool center = point.X >= _resizeBorderWidth && point.X <= _element.ActualWidth - _resizeBorderWidth && point.Y >= _resizeBorderWidth && point.Y <= _element.ActualHeight - _resizeBorderWidth;
        if (top && left)
        {
            return ResizeDirection.TopLeft;
        }
        if (top && right)
        {
            return ResizeDirection.TopRight;
        }
        if (bottom && left)
        {
            return ResizeDirection.BottomLeft;
        }
        if (bottom && right)
        {
            return ResizeDirection.BottomRight;
        }
        if (left)
        {
            return ResizeDirection.Left;
        }
        if (right)
        {
            return ResizeDirection.Right;
        }
        if (top)
        {
            return ResizeDirection.Top;
        }
        if (bottom)
        {
            return ResizeDirection.Bottom;
        }
        if (center)
        {
            return ResizeDirection.Moving;
        }
        return ResizeDirection.None;
    }

    private void UpdateCursor(ResizeDirection direction)
    {
        FrameworkElement element = _element;
        Cursor cursor;
        switch (direction)
        {
            case ResizeDirection.TopLeft:
                cursor = Cursors.SizeNWSE;
                break;
            case ResizeDirection.BottomRight:
                cursor = Cursors.SizeNWSE;
                break;
            case ResizeDirection.TopRight:
                cursor = Cursors.SizeNESW;
                break;
            case ResizeDirection.BottomLeft:
                cursor = Cursors.SizeNESW;
                break;
            case ResizeDirection.Left:
                cursor = Cursors.SizeWE;
                break;
            case ResizeDirection.Right:
                cursor = Cursors.SizeWE;
                break;
            case ResizeDirection.Top:
                cursor = Cursors.SizeNS;
                break;
            case ResizeDirection.Bottom:
                cursor = Cursors.SizeNS;
                break;
            default:
                cursor = Cursors.Arrow;
                break;
        }
        element.Cursor = cursor;
    }

    private UIElement GetParentContainer()
    {
        return VisualTreeHelper.GetParent(_element) as UIElement;
    }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\ScreenHelper.cs

// Version: 0.1.16.93
using System.Windows;
using System.Windows.Controls;

using Thmd.Logs;

namespace Thmd.Utilities;

public static class ScreenHelper
{
	private static WindowLastStance _lastWindowStance;

	private static bool _fullscreen;

	public static bool IsFullscreen => _fullscreen;

	public static WindowLastStance LastWindowStance => _lastWindowStance;

	public static Size GetWindowSize(this object element)
	{
		Window window = Window.GetWindow(element as DependencyObject);
		var windowSize = new Size();
        if (window != null)
		{
			windowSize.Width = window.ActualWidth;
			windowSize.Height = window.ActualHeight;
		}
		return windowSize;
	}

	public static void Fullscreen(this object sender)
	{
		FullscreenOnOff(sender);
	}

	public static void Fullscreen(this object sender, bool fullscreen)
	{
		if (fullscreen == IsFullscreen)
		{
            FullscreenOnOff(sender);
        }
    }

    private static void FullscreenOnOff(object sender)
	{
		Window window = Window.GetWindow(sender as DependencyObject);
		if (window != null)
		{
			if (window.WindowStyle == WindowStyle.None)
			{
				if (_lastWindowStance != null)
				{
					window.ResizeMode = _lastWindowStance.Mode;
					window.WindowStyle = _lastWindowStance.Style;
					window.WindowState = _lastWindowStance.State;
					_fullscreen = false;
					Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"Exit fullscreen: Change video screen from fullscreen to last stance {_lastWindowStance.State}");
					return;
				}
				window.ResizeMode = ResizeMode.CanResize;
				window.WindowStyle = WindowStyle.SingleBorderWindow;
				window.WindowState = WindowState.Normal;
				_fullscreen = false;
				Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"Exit fullscreen: Change video screen from fullscreen to default stance {_lastWindowStance.State}");
			}
			_lastWindowStance = new WindowLastStance
			{
				Mode = window.ResizeMode,
				State = window.WindowState,
				Style = window.WindowStyle
			};
			window.ResizeMode = ResizeMode.NoResize;
			window.WindowStyle = WindowStyle.None;
			window.WindowState = WindowState.Normal;
			window.WindowState = WindowState.Maximized;
			_fullscreen = true;
			Logger.Log.Log(LogLevel.Info, new string[2] { "Console", "File" }, $"Enter fullscreen: Change video screen to fullscreen from last stance {_lastWindowStance.State}");
		}
		else
		{
			Logger.Log.Log(LogLevel.Error, new string[2] { "Console", "File" }, "Fullscreen: Window is null");
		}
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\ShowHideControlsHelper.cs

// Version: 0.1.16.93
using System;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;

namespace Thmd.Utilities;

public class ShowHideControlsHelper
{
	public static async Task Show(Control control, TimeSpan time)
	{
		await Task.Delay(time);
		control.Visibility = Visibility.Visible;
	}

	public static async Task Hide(Control control, TimeSpan time)
	{
		await Task.Delay(time);
		control.Visibility = Visibility.Collapsed;
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\StoryboardHelper.cs

// Version: 0.1.16.92
// StoryboardHelper.cs
// A static helper class that provides extension methods for animating the visibility of WPF controls
// using storyboards. It supports asynchronous hiding and showing of controls with error handling
// and logging for animation operations.

using System;
using System.ComponentModel;
using System.IO.Ports;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media.Animation;
using System.Windows.Threading;

using Thmd.Logs;

namespace Thmd.Utilities;

/// <summary>
/// A static helper class that provides extension methods for animating the visibility of WPF controls
/// using storyboards. Supports asynchronous hiding and showing of controls with error handling
/// and logging for animation operations.
/// </summary>
public static class StoryboardHelper
{
    /// <summary>
    /// Asynchronously hides a control using the specified storyboard animation if the control is visible
    /// and the mouse is not over it.
    /// </summary>
    /// <param name="sender">The control to hide.</param>
    /// <param name="storyboard">The storyboard animation to apply for hiding the control.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    public static async Task HideByStoryboard(this Control sender, Storyboard storyboard)
    {
        if (storyboard != null)
        {
            await sender.Hide(storyboard);
        }
    }

    /// <summary>
    /// Asynchronously shows a control using the specified storyboard animation, making it visible.
    /// </summary>
    /// <param name="sender">The control to show.</param>
    /// <param name="storyboard">The storyboard animation to apply for showing the control.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    public static async Task ShowByStoryboard(this Control sender, Storyboard storyboard)
    {
        if (storyboard != null)
        {
            await sender.Show(storyboard);
        }
    }

    public static async Task RunStoryboad(this  Control sender, Storyboard storyboard)
    {
        if (storyboard != null)
        {
            await sender.Run(storyboard);
        }
    }

    private static async Task Run(this Control sender, Storyboard storyboard)
    {
        Task task = Task.Run(delegate
        {
            try
            {
                sender.Dispatcher.InvokeAsync(delegate
                {
                    storyboard.Begin(sender, HandoffBehavior.Compose, isControllable: false);
                });
            }
            catch (Exception ex)
            {
                Logger.Log.Log(LogLevel.Error, new string[] { "Console", "File" }, ex.Message ?? "");
            }
        });
        await Task.FromResult(task).Result;
    }

    /// <summary>
    /// Asynchronously hides a control using the specified storyboard animation if the control is visible
    /// and the mouse is not over it. Logs any errors that occur during the operation.
    /// </summary>
    /// <param name="sender">The control to hide.</param>
    /// <param name="storyboard">The storyboard animation to apply.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    private static async Task Hide(this Control sender, Storyboard storyboard)
    {
        Task task = Task.Run(delegate
        {
            try
            {
                sender.Dispatcher.InvokeAsync(delegate
                {
                    if (sender.IsVisible && !sender.IsMouseOver)
                    {
                        storyboard.AutoReverse = false;
                        storyboard.Begin(sender, HandoffBehavior.Compose, isControllable: false);
                    }
                });
            }
            catch (Exception ex)
            {
                Logger.Log.Log(LogLevel.Error, new string[] { "Console", "File" }, ex.Message ?? "");
            }
        });
        await Task.FromResult(task).Result;
    }

    /// <summary>
    /// Asynchronously shows a control by setting its visibility to Visible and applying the specified
    /// storyboard animation. Logs any errors that occur during the operation.
    /// </summary>
    /// <param name="sender">The control to show.</param>
    /// <param name="storyboard">The storyboard animation to apply.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    private static async Task Show(this Control sender, Storyboard storyboard)
    {
        Task task = Task.Run(delegate
        {
            try
            {
                sender.Dispatcher.InvokeAsync(delegate
                {
                    sender.Visibility = Visibility.Visible;
                    storyboard.AutoReverse = false;
                    storyboard.Begin(sender, HandoffBehavior.Compose, isControllable: false);
                });
            }
            catch (Exception ex)
            {
                Logger.Log.Log(LogLevel.Error, new string[] { "Console", "File" }, ex.Message ?? "");
            }
        });
        await Task.FromResult(task).Result;
    }
    /*
    public static async Task ShowWithOpacity(this Control element)
    {
        if (DesignerProperties.GetIsInDesignMode(element))
            return;

        await element.Dispatcher.InvokeAsync(() =>
        {
            // Create a Storyboard
            Storyboard storyboard = new Storyboard();

            // Create a DoubleAnimation for opacity
            DoubleAnimation opacityAnimation = new DoubleAnimation
            {
                From = 1.0, // Start at full transparent
                To = 0.0,   // End at fully opacity
                AutoReverse = false,
                FillBehavior = FillBehavior.HoldEnd,
                Duration = TimeSpan.FromSeconds(4), // Animation duration (1 second)
                EasingFunction = new QuadraticEase { EasingMode = EasingMode.EaseInOut } // Optional easing
            };

            // Set the target property to Opacity
            Storyboard.SetTarget(opacityAnimation, element); // Replace 'targetElement' with your UI element
            Storyboard.SetTargetProperty(opacityAnimation, new PropertyPath(UIElement.OpacityProperty));
            Storyboard.SetTargetName(element, "fadeIn");
            // Add the animation to the Storyboard
            storyboard.Children.Add(opacityAnimation);
            // Start the Storyboard
            storyboard.Begin();
        });
    }

    public static async Task StopOpacityStoryboard(this Control element)
    {
        if (DesignerProperties.GetIsInDesignMode(element))
            return;

        await element.Dispatcher.InvokeAsync(() =>
        {
            
        });
    }

    public static async Task HideWithOpacity(this Control element)
    {
        if (DesignerProperties.GetIsInDesignMode(element))
            return;

        await element.Dispatcher.InvokeAsync(() =>
        {
            // Create a Storyboard
            Storyboard storyboard = new Storyboard();

            // Create a DoubleAnimation for opacity
            DoubleAnimation opacityAnimation = new DoubleAnimation
            {
                From = 0.0, // Start at full opacity
                To = 1.0,   // End at fully transparent
                Duration = TimeSpan.FromSeconds(2), // Animation duration (1 second)
                FillBehavior = FillBehavior.HoldEnd,
                AutoReverse = false,
                EasingFunction = new QuadraticEase { EasingMode = EasingMode.EaseInOut } // Optional easing
            };

            // Set the target property to Opacity
            Storyboard.SetTarget(opacityAnimation, element); // Replace 'targetElement' with your UI element
            Storyboard.SetTargetName(element, "fadeOut");
            Storyboard.SetTargetProperty(opacityAnimation, new PropertyPath(UIElement.OpacityProperty));

            // Add the animation to the Storyboard
            storyboard.Children.Add(opacityAnimation);
            // Start the Storyboard
            storyboard.Begin();
        });
    }*/
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\VideoTypeChecker.cs

// Version: 0.1.16.93
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Thmd.Media;

namespace Thmd.Utilities;

public class VideoTypeChecker
{
	private readonly string _filePath;

	public bool IsAvi { get; }

	public bool IsMp4 { get; }

	public bool IsM3u8 { get; }

	public VideoTypeChecker(string filePath)
	{
		_filePath = filePath;
		string extension = Path.GetExtension(filePath).ToLowerInvariant();
		IsAvi = extension == ".avi";
		IsMp4 = extension == ".mp4";
		IsM3u8 = extension == ".m3u8";
	}

	public void DownloadM3u8(string outputPath)
	{
		ValidateM3u8();
		Console.WriteLine("Downloading M3U8 stream from " + _filePath + " to " + outputPath);
	}

	public async Task<string[]> ParseM3u8Async()
	{
		ValidateM3u8();
		Console.WriteLine("Parsing M3U8 playlist from " + _filePath);
		new List<string>();
		HLSStreamer streamer = new HLSStreamer();
		streamer.PlaylistParsed += delegate(List<HlsSegment> segments)
		{
			Console.WriteLine($"Loaded playlist with {segments.Count} segments");
			foreach (HlsSegment current in segments)
			{
				Console.WriteLine(current.Title, current.Duration);
			}
		};
		streamer.ErrorOccurred += delegate(string error)
		{
			Console.WriteLine("Error: " + error);
		};
		streamer.StreamEnded += delegate
		{
			Console.WriteLine("Stream ended");
		};
		streamer.StartStreamingAsync(cancellationToken: new CancellationTokenSource().Token, m3u8Url: _filePath);
		await Task.Delay(30000);
		streamer.StopStreaming();
		streamer.Dispose();
		return Array.Empty<string>();
	}

	private void Stream_StreamEnded()
	{
		throw new NotImplementedException();
	}

	public Stream GetStream()
	{
		ValidateM3u8();
		Console.WriteLine("Getting stream from " + _filePath);
		return Stream.Null;
	}

	private void ValidateM3u8()
	{
		if (!IsM3u8)
		{
			throw new InvalidOperationException("Operation available only for M3U8 streams");
		}
	}

	public override string ToString()
	{
		return "VideoItem type: " + (IsAvi ? "AVI" : IsMp4 ? "MP4" : IsM3u8 ? "M3U8" : "Unknown");
	}
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Utilities\WindowLastStance.cs

// Version: 0.1.16.93
using System.Windows;

namespace Thmd.Utilities;

public class WindowLastStance
{
	public WindowState State { get; set; }

	public ResizeMode Mode { get; set; }

	public WindowStyle Style { get; set; }
}



// OtherInformation: Compare this snippet from F:\dev\Thmd\Thmd\Windowses\WindowPropertiesExtensions.cs

// Version: 0.1.16.93
using System;
using System.Runtime.InteropServices;
using System.Windows;

namespace Thmd.Windowses;

public static class WindowPropertiesExtensions
{
	public struct W32Point
	{
		public int X;

		public int Y;
	}

	internal struct W32MonitorInfo
	{
		public int Size;

		public W32Rect Monitor;

		public W32Rect WorkArea;

		public uint Flags;
	}

	internal struct W32Rect
	{
		public int Left;

		public int Top;

		public int Right;

		public int Bottom;
	}

	[DllImport("user32.dll", SetLastError = true)]
	[return: MarshalAs(UnmanagedType.Bool)]
	private static extern bool GetCursorPos(ref W32Point pt);

	[DllImport("user32.dll", SetLastError = true)]
	[return: MarshalAs(UnmanagedType.Bool)]
	private static extern bool GetMonitorInfo(IntPtr hMonitor, ref W32MonitorInfo lpmi);

	[DllImport("user32.dll")]
	private static extern IntPtr MonitorFromPoint(W32Point pt, uint dwFlags);

	public static bool ActivateCenteredToMouse(this Window window)
	{
		ComputeTopLeft(ref window);
		return window.Activate();
	}

	public static void ShowCenteredToMouse(this Window window)
	{
		WindowStartupLocation oldLocation = window.WindowStartupLocation;
		window.WindowStartupLocation = WindowStartupLocation.Manual;
		ComputeTopLeft(ref window);
		window.Show();
		window.WindowStartupLocation = oldLocation;
	}

	private static void ComputeTopLeft(ref Window window)
	{
		W32Point pt = default;
		if (!GetCursorPos(ref pt))
		{
			Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
		}
		IntPtr monHandle = MonitorFromPoint(pt, 2u);
		W32MonitorInfo monInfo = new W32MonitorInfo
		{
			Size = Marshal.SizeOf(typeof(W32MonitorInfo))
		};
		if (!GetMonitorInfo(monHandle, ref monInfo))
		{
			Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
		}
		W32Rect monitor = monInfo.WorkArea;
		double offsetX = Math.Round(window.Width / 2.0);
		double offsetY = Math.Round(window.Height / 2.0);
		double top = pt.Y - offsetY;
		double left = pt.X - offsetX;
		Rect screen = new Rect(new Point(monitor.Left, monitor.Top), new Point(monitor.Right, monitor.Bottom));
		Rect wnd = new Rect(new Point(left, top), new Point(left + window.Width, top + window.Height));
		window.Top = wnd.Top;
		window.Left = wnd.Left;
		if (!screen.Contains(wnd))
		{
			if (wnd.Top < screen.Top)
			{
				double diff = Math.Abs(screen.Top - wnd.Top);
				window.Top = wnd.Top + diff;
			}
			if (wnd.Bottom > screen.Bottom)
			{
				double diff2 = wnd.Bottom - screen.Bottom;
				window.Top = wnd.Top - diff2;
			}
			if (wnd.Left < screen.Left)
			{
				double diff3 = Math.Abs(screen.Left - wnd.Left);
				window.Left = wnd.Left + diff3;
			}
			if (wnd.Right > screen.Right)
			{
				double diff4 = wnd.Right - screen.Right;
				window.Left = wnd.Left - diff4;
			}
		}
	}
}


